<!DOCTYPE html><html lang="zh-TW"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>SLMT's Blog | PTT Source Code 研究筆記 2</title><link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="stylesheet" type="text/css" href="/css/syntax-highlight.css"><script src="https://use.fontawesome.com/0bc11e7eba.js"></script><!-- Open Graph Protocol--><meta property="og:title" content="PTT Source Code 研究筆記 2"><meta property="og:image" content="http://www.slmt.tw/images/logo.png"><meta property="og:type" content="website"><meta property="og:url" content="/2016/08/07/tracing-ptt-note-2/"><meta property="og:site_name" content="SLMT's Blog"><meta property="og:locale" content="zh-TW"><meta property="og:description" content="基本上，PTT 的使用者連上 PTT 時，都是透過一個叫做 telnet 的 protocol 進行。看了 PTT 的程式碼，會發現 PTT 並沒有使用其它的 telnet 函式庫，而是自行實作 telnet protocol。剛剛將這個部分看的差不多了，因此稍微紀錄一下實作方式。"></head><body><div id="container"><div id="header"><h1 class="title">SLMT's Blog</h1><div class="pure-g navs"><div class="nav pure-u-1 pure-u-sm-1-4"><a href="/.">Home</a></div><div class="nav pure-u-1 pure-u-sm-1-4"><a href="/archives">Archive</a></div><div class="nav pure-u-1 pure-u-sm-1-4"><a href="/about">About</a></div><div class="nav pure-u-1 pure-u-sm-1-4"><a href="/rss.xml">RSS</a></div></div></div><div id="main"><h1 class="post-large-title">PTT Source Code 研究筆記 2</h1><div class="post-meta"><div class="post-date"><i class="fa fa-calendar" aria-hidden="true"></i>2016/08/07</div><div class="post-cats"><i class="fa fa-folder-open" aria-hidden="true"></i><a class="post-cat" href="/categories/research/">Research</a>/<a class="post-cat" href="/categories/research/ptt/">PTT</a>/<a class="post-cat" href="/categories/research/ptt/source-code/">Source Code</a></div><div class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a class="post-tag" href="/tags/code/">#code</a><a class="post-tag" href="/tags/tracing/">#tracing</a><a class="post-tag" href="/tags/ptt/">#ptt</a><a class="post-tag" href="/tags/bbs/">#bbs</a></div></div><div class="post-content"><p>基本上，PTT 的使用者連上 PTT 時，都是透過一個叫做 telnet 的 protocol 進行。看了 PTT 的程式碼，會發現 PTT 並沒有使用其它的 telnet 函式庫，而是自行實作 telnet protocol。剛剛將這個部分看的差不多了，因此稍微紀錄一下實作方式。</p>
<a id="more"></a>
<h2 id="簡介-Telnet-Protocol"><a href="#簡介-Telnet-Protocol" class="headerlink" title="簡介 Telnet Protocol"></a>簡介 Telnet Protocol</h2><p>Telnet Protocol 的基本概念定義在 RFC 854 中，需要的話可以透過底下的 reference 看到全文。內容我花一點時間大致看過了，其實概念不難理解。</p>
<p>Telnet 是一種建立在 TCP 上的通訊協定。TCP 基本上處理好了傳送訊息過程中的各種錯誤，因此 telnet 很少需要處理甚麼錯誤的情況。Telnet 的基本概念是在模擬過去電腦的工作模式。很早期以前的電腦是有一台大型的主機 (mainframe) 在進行計算，然後使用者必須要透過一台小型的終端機 (terminal) 來連上主機進行工作 (就像下圖一樣)。跟現在這種一台電腦一個螢幕，然後螢幕的顯示直接由主機負責很不一樣。以前的模式裡，終端機很像是一個 client，主機則是 server。終端機會負責接收使用者訊息，透過線路送出指令，並顯示結果。Telnet 大概也類似這樣。Server 上儲存各種資料，每個使用者自己電腦的 telnet client 就是一個終端機。連上 server 後，server 會把你畫面上該顯示的東西傳過來給你，client 則會印出收到的文字。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/7/7d/IBM_704_mainframe.gif"></p>
<p>了解基本概念之後，就會知道 telnet 其實該作的事情不多。基本上 server 就是會把一個個你畫面上該顯示的文字傳遞給 client，client 則會下達指令給 server。唯一要特別處理的，就是兩者間必須要能夠透過一些預先定義好的指令，來設定兩者傳遞資料的一些規則。</p>
<h2 id="PTT’s-Telnet-Implementation"><a href="#PTT’s-Telnet-Implementation" class="headerlink" title="PTT’s Telnet Implementation"></a>PTT’s Telnet Implementation</h2><p>PTT 自行實作了 telnet protocol，主要是由當時在台大資工系的 piaip 實作。程式碼可以在 PTT Source Code 的 <code>common/sys/telnet.c</code> 中找到。內容非常簡單，大概一個下午就可以看完。不過也因為實作非常簡單，所以對於很多設定的選項並不會給予回覆。在該檔之中有一段註解寫著：</p>
<blockquote>
<p>We are the boss. We don’t respect to client. It’s client’s responsibility to follow us.</p>
</blockquote>
<p>我看到這段霸氣註解之後笑了一下XD</p>
<p>不過也多虧這個決定，這邊就有很多實作的細節都可以跳過。</p>
<p>基本上實作的程式碼大概可以分成三塊：</p>
<ul>
<li>剛開始連線時，會送出一些初始設定資訊</li>
<li>讓 server 其他部分調整一些基本設定</li>
<li>處理 client 送來的設定</li>
</ul>
<p>這邊可以發現主要都是在實作關於設定的通訊。其他像是處理 server 送出的畫面內容、如何處理 client 對於 PTT 的指令這些，就不是 telnet protocol 本身的工作。因此並沒有寫在這裡。</p>
<h3 id="起始設定"><a href="#起始設定" class="headerlink" title="起始設定"></a>起始設定</h3><p>一開始 server 會將一連串的設定訊息送給 client，client 收到後則會對每個訊息做出回應。PTT 送出的設定可以在 <code>telnet.c</code> 的 <code>telnet_init_cmds</code> 這個變數內找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> telnet_init_cmds[] = &#123;</div><div class="line">	 <span class="comment">// retrieve terminal type and throw away.</span></div><div class="line"> 	 <span class="comment">// why? because without this, clients enter line mode.</span></div><div class="line">	 IAC, DO, TELOPT_TTYPE,</div><div class="line">	 IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE,</div><div class="line"></div><div class="line">	 <span class="comment">// i'm a smart term with resize ability.</span></div><div class="line">	 IAC, DO, TELOPT_NAWS,</div><div class="line"></div><div class="line">	 <span class="comment">// i will echo.</span></div><div class="line">	 IAC, WILL, TELOPT_ECHO,</div><div class="line">	 <span class="comment">// supress ga.</span></div><div class="line">	 IAC, WILL, TELOPT_SGA,</div><div class="line">	 <span class="comment">// 8 bit binary.</span></div><div class="line">	 IAC, WILL, TELOPT_BINARY,</div><div class="line">	 IAC, DO,   TELOPT_BINARY,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中使用到的常數都定義在 <code>arpa/telnet.h</code> 中。這個檔案並不是 PTT 的一部分，而是大多數系統都會包含的標頭檔。上網搜尋一下就可以找到檔案。這些初始訊息翻譯成人話的話，意思大概如下 (以下每一行分別對應到上面一行)：</p>
<ul>
<li>現在來設定終端機種類吧 (TELOPT_TTYPE)</li>
<li>請給我終端機種類設定資訊</li>
<li>現在來設定終端機大小吧 (TELOPT_NAWS)</li>
<li>希望你能回應每個我傳送的訊息 (TELOPT_ECHO)</li>
<li>希望你能夠直接傳送下個訊息，而不要等我回覆 (TELOPT_SGA)</li>
<li>希望你能使用 8bit 傳輸模式 (TELOPT_BINARY)</li>
</ul>
<p>特別注意註解中有提到，若不送出前兩項設定訊息，client 可能就無法正確地顯示出 PTT 畫面。</p>
<h3 id="處理-client-設定訊息"><a href="#處理-client-設定訊息" class="headerlink" title="處理 client 設定訊息"></a>處理 client 設定訊息</h3><p>至於 client 這邊送回來的訊息，處理的方式基本上就是一個 finite state machine (FSM)。FSM 的概念就是程式會有一組狀態。每次收到訊號之後，檢查現在的狀態是甚麼，然後做出對應的動作，最後更新目前的狀態。詳細的部分各位有興趣可以自己去看，那段程式碼才大概 224 行，很快就可以看完。</p>
<p>大概需要注意的是，若收到 client 傳出的 <code>IAC SB</code> 訊息，那就會進入一個<strong>暫存</strong>狀態。接下來所有收到的訊息都會被放近一個 buffer 之中，直到收到 <code>SE</code> 指令為止。這個動作意義在於，<code>IAC SB</code> 是代表接下來收到的是關於某個選項的詳細資訊，例如選項若是 <code>TELOPT_NAWS</code>，那接下來就會收到終端機的長跟高的資訊。有趣的是，PTT 似乎只會對 <code>TELOPT_NAWS</code> 這個選項做出反應，其他的選項則大多都被忽略掉了。</p>
<h3 id="實際例子"><a href="#實際例子" class="headerlink" title="實際例子"></a>實際例子</h3><p>目前我用 Rust 撰寫的 <a href="https://github.com/SLMT/rust-ptt/tree/5246412a8ca514823c01e2cc40c4ee06d281e9cf" target="_blank" rel="external">PTT prototype</a> 已經可以送出前兩章看到的基本設定，以及接收 client 的訊息。</p>
<p>我使用 PCMan 來測試，發現 PCMan 在收到我的訊息後，會回傳下列訊息 (in bytes)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">255, 251, 24, 255, 250, 24, 0, 86, 84, 49, 48, 48, 255, 240, 255, 251, 31, 255, 250, 31, 0, 80, 0, 24, 255, 240, 255, 253, 1, 255, 253, 3, 255, 254, 0, 255, 252, 0</div></pre></td></tr></table></figure>
<p>若轉換為各自代表的意義，則大概是這樣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">IAC, WILL, TELOPT_TTYPE</div><div class="line">IAC, SB, &#123;TELOPT_TTYPE, TELQUAL_IS, 86, 84, 49, 48, 48, 255&#125;, SE</div><div class="line">IAC, WILL, TELOPT_NAWS</div><div class="line">IAC, SB, &#123;TELOPT_NAWS, width&#123;0, 80&#125;, height&#123;0, 24&#125;, 255&#125;, SE</div><div class="line">IAC, DO, TELOPT_ECHO,</div><div class="line">IAC, DO, TELOPT_SGA,</div><div class="line">IAC, DONT, TELOPT_BINARY,</div><div class="line">IAC, WONT, TELOPT_BINARY</div></pre></td></tr></table></figure>
<p>這邊可以看到像是對於 <code>TELOPT_NAWS</code> 這個選項，PCMan 送出了寬 80、高 24 的訊息。而 PTT 這邊就會依照他的請求來調整大小。其中有一個有趣的點是，PCMan 送出了他不會使用 8bit 模式的訊息。而 PTT 這邊則是看完之後就丟掉了。這感覺就像是以下發生了以下情境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PTT: 請使用 8-bit 模式</div><div class="line">PCMan: 我不能使用 8-bit 模式</div><div class="line">PTT: 哦，是哦。</div></pre></td></tr></table></figure>
<p>大概就是這樣吧XD</p>
<p>這邊了解之後，會先花點時間實作在 Rust-PTT 上，之後應該會進入 PTT 上關於 terminal 的實作。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>PTT Source Code - <a href="https://github.com/ptt/pttbbs" target="_blank" rel="external">https://github.com/ptt/pttbbs</a></li>
<li>我的 PTT Source Code 閱讀紀錄 - <a href="https://github.com/SLMT/pttbbs/tree/tracing" target="_blank" rel="external">https://github.com/SLMT/pttbbs/tree/tracing</a></li>
<li>Rust PTT Project - <a href="https://github.com/SLMT/rust-ptt" target="_blank" rel="external">https://github.com/SLMT/rust-ptt</a></li>
<li>PTT Source Code 中的 telnet.c - <a href="https://github.com/ptt/pttbbs/blob/master/common/sys/telnet.c" target="_blank" rel="external">https://github.com/ptt/pttbbs/blob/master/common/sys/telnet.c</a></li>
<li>RFC 854 - Telnet Protocol Specification - <a href="https://tools.ietf.org/html/rfc854" target="_blank" rel="external">https://tools.ietf.org/html/rfc854</a></li>
<li>PCMan - <a href="http://pcman.ptt.cc/" target="_blank" rel="external">http://pcman.ptt.cc/</a></li>
</ul>
</div><div id="disqus_thread"><script>var disqus_shortname = 'slmtsblog';
var disqus_identifier = '2016/08/07/tracing-ptt-note-2/';
var disqus_title = 'PTT Source Code 研究筆記 2';
var disqus_url = 'http://www.slmt.tw/2016/08/07/tracing-ptt-note-2/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div><div id="footer"><p>&copy; Yu-shan Lin (SLMT) and SLMT's Blog, 2016</p></div></div></body></html>