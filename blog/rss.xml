<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SLMT&#39;s Blog</title>
  
  <link href="/blog/rss.xml" rel="self"/>
  
  <link href="http://www.slmt.tw/blog/"/>
  <updated>2017-08-04T06:45:06.000Z</updated>
  <id>http://www.slmt.tw/blog/</id>
  
  <author>
    <name>SLMT</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>漏洞筆記 - 別讓你的 .git 資料夾公開在網路上啊！</title>
    <link href="http://www.slmt.tw/blog/2016/08/22/dont-expose-your-git-dir/"/>
    <id>http://www.slmt.tw/blog/2016/08/22/dont-expose-your-git-dir/</id>
    <published>2016-08-21T16:00:45.000Z</published>
    <updated>2017-08-04T06:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>這個周末玩了一個 CTF 線上賽。其中有一題是說有一個新手架了一個網站，然後分別使用了 Nginx、PHP、git 這些技術。點開題目提供的網址後，就看到一個 Hello World 的網頁。打開原始碼後，只看到幾行簡單的基礎程式碼，也沒有看到可疑的東西。正當我打算要放棄的時候，突然想到題目有特別提到他有使用 git。於是就嘗試了打開該網站的 <code>.git</code> 資料夾，不過馬上就被 403 Forbidden 打臉。</p>
<p>就在我快想不到到底怎麼辦的時候，突然又靈機一動。想到雖然我看不到 <code>.git</code> 的內容，但或許我仍可以下載裡面的檔案？於是我馬上隨便打開我手邊的一個 git repository。發現 <code>.git</code> 資料夾內一定有 <code>HEAD</code> 這個檔案。於是我馬上就嘗試下載 <code>.git/HEAD</code>。果不其然！可以抓到這個檔案！那麼接下來就有個方向了！</p>
<a id="more"></a>
<h2 id="git-資料夾"><a href="#git-資料夾" class="headerlink" title=".git 資料夾"></a><code>.git</code> 資料夾</h2><p>稍微研究了一下，一個 <code>.git</code> 的資料夾大概有 <code>hooks</code>、<code>info</code>、<code>logs</code>、<code>objects</code>、<code>refs</code>，檔案則大概有 <code>COMMIT_EDITMSG</code>、<code>config</code>、<code>description</code>、<code>HEAD</code>。</p>
<p>其中 <code>hooks</code>、<code>info</code> 這兩個資料夾在大多數的 <code>.git</code> 之中都沒有甚麼有用的資訊，<code>logs</code> 則是其中可以馬上看出最多資訊的資料夾。<code>objects</code> 則存著所有版本的 binary 檔，裡面的東西乍看之下沒有甚麼規則，於是我先跳過。<code>refs</code> 則存放每個 branch 目前指向的 commit 為何。</p>
<p>除了 <code>objects</code> 以外，所有檔案的檔名大多可以猜到，因此我就將這些檔案抓了下來。可惜裡面最多只能從 log 中看出曾經有 commit 過含有 flag 的檔案。但是檔案的實際內容就無從得知了。</p>
<h2 id="Git-Objects"><a href="#Git-Objects" class="headerlink" title="Git Objects"></a>Git Objects</h2><p>我發現我似乎最後仍得要還原出每個版本，才有辦法解出這題。因此我開始研究了 <code>objects</code> 內的內容。後來稍微思考了一下，覺得 git 官方應該會有相關的文件。Google 一下很快就有發現了！果然有關於內部運作邏輯的文件，甚至連 objects 的存放方式跟意義都有明確說明。甚至還有繁體中文版！文件有興趣的可以參考看看：</p>
<p><a href="https://git-scm.com/book/zh-tw/v1/Git-%E5%85%A7%E9%83%A8%E5%8E%9F%E7%90%86" target="_blank" rel="external">https://git-scm.com/book/zh-tw/v1/Git-%E5%85%A7%E9%83%A8%E5%8E%9F%E7%90%86</a></p>
<p>大略看過之後，才知道原來所有的 commit 的文件都會獨立存成一個檔案。每個檔案會先計算 SHA1 值為多少，然後取前兩碼做為 <code>objects</code> 內的資料夾名稱，後 38 碼則做為 <code>objects</code> 內部的檔名存放。在 <code>objects</code> 中，除了存放 commit 的檔案外，還會存放 commit 時的目錄結構 (稱為 tree)，以及 commit 的紀錄。這些也同樣會用上述的方式存起來。目錄會紀錄裡面包含的其他目錄以及檔案的 SHA1 值為何。Commit 紀錄則會有該次 commit 對應的目錄 SHA1 值，以及上一次 commit 的 SHA1 值。</p>
<p>這些檔案都被以 binary 的方式存起來。我稍微查了一下有沒有簡便的方法可以直接看到內容。果不其然，可以透過 <code>git cat-file</code> 指令解碼 objects 的內容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git cat-file -p [SHA1]</div></pre></td></tr></table></figure>
<p><code>[SHA1]</code> 處要填上你想要解碼的 object 檔的 SHA1 值，有興趣的人可以自己試試看。記住 SHA1 前兩碼是資料夾名稱，後 38 碼是檔案名稱。</p>
<h2 id="檢查指令"><a href="#檢查指令" class="headerlink" title="檢查指令"></a>檢查指令</h2><p>在得知這些資訊後，我馬上去查看 log 檔，找到 commit 的 SHA1 值，然後嘗試去下載對應的 object 檔。一試之後，馬上就成功下載對應的檔案。我接著立刻用查到的指令解碼，就看到了類似下列的內容：(這個內容是我拿我的部落格 git 資料夾 demo)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tree 9aa33d38927cdde7b969586a2a7e942d816ea947</div><div class="line">parent bfd06e73e40a78720418795cacc3072bad168d85</div><div class="line">author slmt &lt;sam123456777@gmail.com&gt; 1471021607 +0800</div><div class="line">committer slmt &lt;sam123456777@gmail.com&gt; 1471021607 +0800</div><div class="line"></div><div class="line">Add a new post</div></pre></td></tr></table></figure>
<p><code>tree</code> 指的就是該次 commit 對應的目錄檔，<code>parent</code> 指的是上一次 commit 的 SHA1 值。其他則是容易辨別的 commit 資料。</p>
<p>我馬上就知道我又獲得了兩個 SHA1，所以就繼續使用這些 SHA1 下載對應的 object 檔。只是多試幾次之後，很快就感到厭煩了。因為你要先解碼，還要看哪一個是沒有抓過的。全部抓下來的話很花時間。</p>
<p>幸好我後來又發現另一個指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fsck</div></pre></td></tr></table></figure>
<p>這個指令會檢查你的 objects 檔之間的 link 是否完整，並且會找出應該存在但是找不到的 object 檔。這個指令大大地幫助我減少檢查檔案的時間。於是我很快就把遺失的 object 檔補齊。找到所有 object 檔後，很輕易地就使用常用的 git 指令找出了之前的版本，然後發現題目要求的 flag。順利解決。</p>
<h2 id="下載-Script"><a href="#下載-Script" class="headerlink" title="下載 Script"></a>下載 Script</h2><p>寫完這題之後，我覺得雖然有 <code>git fsck</code> 幫助，但是一一下載檔案仍然非常麻煩。因此我就寫了一個 python script 來幫助我進行自動下載。該 script 可以在這裡找到：</p>
<p><a href="https://github.com/SLMT/ctf-tools/tree/master/git-repository-downloader" target="_blank" rel="external">https://github.com/SLMT/ctf-tools/tree/master/git-repository-downloader</a></p>
<p>基本上 script 就是做我前列提到的那些事情，只是變成只要輸入一個指令就可以完成所有動作。</p>
<h2 id="呼籲"><a href="#呼籲" class="headerlink" title="呼籲"></a>呼籲</h2><p>最後呼籲一下。別忘記這題會被解開是因為 <code>.git</code> 的下載權限被設為公開。若之後大家在開發網站，別忘記把 <code>.git</code> 的下載權限關掉。只有關掉閱讀目錄的權限還遠遠不夠，只要使用我的 script 就可以完整地復原整個 git repository XD 因此真的要很小心~~!!!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這個周末玩了一個 CTF 線上賽。其中有一題是說有一個新手架了一個網站，然後分別使用了 Nginx、PHP、git 這些技術。點開題目提供的網址後，就看到一個 Hello World 的網頁。打開原始碼後，只看到幾行簡單的基礎程式碼，也沒有看到可疑的東西。正當我打算要放棄的時候，突然想到題目有特別提到他有使用 git。於是就嘗試了打開該網站的 &lt;code&gt;.git&lt;/code&gt; 資料夾，不過馬上就被 403 Forbidden 打臉。&lt;/p&gt;
&lt;p&gt;就在我快想不到到底怎麼辦的時候，突然又靈機一動。想到雖然我看不到 &lt;code&gt;.git&lt;/code&gt; 的內容，但或許我仍可以下載裡面的檔案？於是我馬上隨便打開我手邊的一個 git repository。發現 &lt;code&gt;.git&lt;/code&gt; 資料夾內一定有 &lt;code&gt;HEAD&lt;/code&gt; 這個檔案。於是我馬上就嘗試下載 &lt;code&gt;.git/HEAD&lt;/code&gt;。果不其然！可以抓到這個檔案！那麼接下來就有個方向了！&lt;/p&gt;
    
    </summary>
    
      <category term="Hacking" scheme="http://www.slmt.tw/blog/categories/hacking/"/>
    
      <category term="Exploit" scheme="http://www.slmt.tw/blog/categories/hacking/exploit/"/>
    
    
      <category term="hacking" scheme="http://www.slmt.tw/blog/tags/hacking/"/>
    
      <category term="web" scheme="http://www.slmt.tw/blog/tags/web/"/>
    
      <category term="exploit" scheme="http://www.slmt.tw/blog/tags/exploit/"/>
    
      <category term="git" scheme="http://www.slmt.tw/blog/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Rust-PTT 開發筆記 1</title>
    <link href="http://www.slmt.tw/blog/2016/08/13/rust-ptt-notes-1/"/>
    <id>http://www.slmt.tw/blog/2016/08/13/rust-ptt-notes-1/</id>
    <published>2016-08-12T16:34:51.000Z</published>
    <updated>2017-08-04T06:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早以前我就想深入研究 PTT 的程式碼，雖然 PTT 很早就將程式碼開源出來，但是當時我並沒有能力看懂。最近又將程式碼翻出來看，看了一些之後有些心得。剛好在 PTT 上有人在<a href="https://github.com/ptt/pttbbs/issues/5" target="_blank" rel="external">討論重寫 PTT</a> 的問題，因此就讓我起了重寫 PTT 的意思。</p>
<p>這裡我選擇使用 Rust 做為重寫的語言。主要是因為我最近在研究這個程式語言，但是一直沒有甚麼機會寫出比較大的專案。因此我認為用 Rust 寫 PTT 剛好是個不錯的機會，於是這個專案就這麼開始了！</p>
<p>從這裡可以到 Rust-PTT 的 Github 頁面：<a href="https://github.com/SLMT/rust-ptt/" target="_blank" rel="external">https://github.com/SLMT/rust-ptt/</a></p>
<a id="more"></a>
<h2 id="為什麼選擇-Rust"><a href="#為什麼選擇-Rust" class="headerlink" title="為什麼選擇 Rust"></a>為什麼選擇 Rust</h2><p><a href="https://www.rust-lang.org/en-US/" target="_blank" rel="external">Rust</a> 是很新的程式語言，去年 (2015) 5 月 16 號才釋出 1.0 正式版。最近也才剛進到 1.10.0 而已。很多東西都還在討論之中，但是大多數的東西應該都差不多定型了。</p>
<p>Rust 語言具有不會有 Segmentation Falut、不需自己管理記憶體 (但是也不用 Garbage Collection 等方式降低執行效能)、近似於 C 效能等特性。同時該語言融合了許多近期新興語言的特色，像是 Pattern Matching、Closures、Generics 等等，並且在於 Concurrency 的方面具有許多 Native Support。我認為 Rust 很適合用來開發大量用戶同時連線的 PTT，而且相較於 C 更容易維護。</p>
<p>Rust 語言目前由 Mozilla 公司開發維護，並且正以 Rust 與開發 Firefox 的經驗，重新撰寫<a href="https://github.com/servo/servo" target="_blank" rel="external">新的瀏覽器核心</a>。現在也有其它專案正在重新以 Rust 替換掉原本以 C 撰寫的程式。</p>
<h2 id="近期進度"><a href="#近期進度" class="headerlink" title="近期進度"></a>近期進度</h2><p>撰寫這篇文章的同時，我已經 commit 了 8 個版本。目前最新的版本為 <a href="https://github.com/SLMT/rust-ptt/commit/a63e83012f479ceea13b01fcdd037ae56ce857f5" target="_blank" rel="external">a63e830</a>。</p>
<p>一開始只有 Hello World，八個版本後已經有一個基本的 TCP Server，並且會對 Telnet Protocol 做一些初始化的動作。若一個 telnet client 嘗試連上目前的 server，在進行 telnet 初始化之後，server 會知道 client 需要多大的 terminal size。</p>
<p>目前 telnet 的實作主要是根據 PTT 內的實作方式進行，詳情可以參考我撰寫的另一篇文章：<a href="http://www.slmt.tw/2016/08/07/tracing-ptt-note-2/">PTT Source Code 研究筆記 2</a>。</p>
<h2 id="嘗試看看"><a href="#嘗試看看" class="headerlink" title="嘗試看看"></a>嘗試看看</h2><p>假設你的電腦已經安裝好 Rust 與 Git，你可透過在 shell 輸入下列指令啟動 rust-ptt 的 server：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; git clone https://github.com/SLMT/rust-ptt</div><div class="line">&gt; cd rust-ptt</div><div class="line">&gt; cargo run</div></pre></td></tr></table></figure>
<p>之後啟動都只要執行最後一個指令即可。</p>
<p>然後隨便找一個拿來連 PTT 的 client 或者 telnet client 來連上 server (網址：<code>localhost:54321</code>)，此時 server 這邊應該會顯示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Start a connection to 127.0.0.1:4229</div><div class="line">Width: 80, Height: 24</div></pre></td></tr></table></figure>
<p>第一行是 client 的資訊，第二行是 client 要求的 terminal 大小。目前只能顯示這些東西而已，client 則還不會看到任何結果。</p>
<h2 id="近期目標"><a href="#近期目標" class="headerlink" title="近期目標"></a>近期目標</h2><p>接下來應該會朝向完成基本的 terminal 功能，以及登入功能為主。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早以前我就想深入研究 PTT 的程式碼，雖然 PTT 很早就將程式碼開源出來，但是當時我並沒有能力看懂。最近又將程式碼翻出來看，看了一些之後有些心得。剛好在 PTT 上有人在&lt;a href=&quot;https://github.com/ptt/pttbbs/issues/5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;討論重寫 PTT&lt;/a&gt; 的問題，因此就讓我起了重寫 PTT 的意思。&lt;/p&gt;
&lt;p&gt;這裡我選擇使用 Rust 做為重寫的語言。主要是因為我最近在研究這個程式語言，但是一直沒有甚麼機會寫出比較大的專案。因此我認為用 Rust 寫 PTT 剛好是個不錯的機會，於是這個專案就這麼開始了！&lt;/p&gt;
&lt;p&gt;從這裡可以到 Rust-PTT 的 Github 頁面：&lt;a href=&quot;https://github.com/SLMT/rust-ptt/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SLMT/rust-ptt/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.slmt.tw/blog/categories/project/"/>
    
      <category term="Rust-PTT" scheme="http://www.slmt.tw/blog/categories/project/rust-ptt/"/>
    
    
      <category term="rust" scheme="http://www.slmt.tw/blog/tags/rust/"/>
    
      <category term="code" scheme="http://www.slmt.tw/blog/tags/code/"/>
    
      <category term="ptt" scheme="http://www.slmt.tw/blog/tags/ptt/"/>
    
      <category term="bbs" scheme="http://www.slmt.tw/blog/tags/bbs/"/>
    
      <category term="project" scheme="http://www.slmt.tw/blog/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>PTT Source Code 研究筆記 2</title>
    <link href="http://www.slmt.tw/blog/2016/08/07/tracing-ptt-note-2/"/>
    <id>http://www.slmt.tw/blog/2016/08/07/tracing-ptt-note-2/</id>
    <published>2016-08-07T07:15:00.000Z</published>
    <updated>2017-08-04T06:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>基本上，PTT 的使用者連上 PTT 時，都是透過一個叫做 telnet 的 protocol 進行。看了 PTT 的程式碼，會發現 PTT 並沒有使用其它的 telnet 函式庫，而是自行實作 telnet protocol。剛剛將這個部分看的差不多了，因此稍微紀錄一下實作方式。</p>
<a id="more"></a>
<h2 id="簡介-Telnet-Protocol"><a href="#簡介-Telnet-Protocol" class="headerlink" title="簡介 Telnet Protocol"></a>簡介 Telnet Protocol</h2><p>Telnet Protocol 的基本概念定義在 RFC 854 中，需要的話可以透過底下的 reference 看到全文。內容我花一點時間大致看過了，其實概念不難理解。</p>
<p>Telnet 是一種建立在 TCP 上的通訊協定。TCP 基本上處理好了傳送訊息過程中的各種錯誤，因此 telnet 很少需要處理甚麼錯誤的情況。Telnet 的基本概念是在模擬過去電腦的工作模式。很早期以前的電腦是有一台大型的主機 (mainframe) 在進行計算，然後使用者必須要透過一台小型的終端機 (terminal) 來連上主機進行工作 (就像下圖一樣)。跟現在這種一台電腦一個螢幕，然後螢幕的顯示直接由主機負責很不一樣。以前的模式裡，終端機很像是一個 client，主機則是 server。終端機會負責接收使用者訊息，透過線路送出指令，並顯示結果。Telnet 大概也類似這樣。Server 上儲存各種資料，每個使用者自己電腦的 telnet client 就是一個終端機。連上 server 後，server 會把你畫面上該顯示的東西傳過來給你，client 則會印出收到的文字。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/7/7d/IBM_704_mainframe.gif"></p>
<p>了解基本概念之後，就會知道 telnet 其實該作的事情不多。基本上 server 就是會把一個個你畫面上該顯示的文字傳遞給 client，client 則會下達指令給 server。唯一要特別處理的，就是兩者間必須要能夠透過一些預先定義好的指令，來設定兩者傳遞資料的一些規則。</p>
<h2 id="PTT’s-Telnet-Implementation"><a href="#PTT’s-Telnet-Implementation" class="headerlink" title="PTT’s Telnet Implementation"></a>PTT’s Telnet Implementation</h2><p>PTT 自行實作了 telnet protocol，主要是由當時在台大資工系的 piaip 實作。程式碼可以在 PTT Source Code 的 <code>common/sys/telnet.c</code> 中找到。內容非常簡單，大概一個下午就可以看完。不過也因為實作非常簡單，所以對於很多設定的選項並不會給予回覆。在該檔之中有一段註解寫著：</p>
<blockquote>
<p>We are the boss. We don’t respect to client. It’s client’s responsibility to follow us.</p>
</blockquote>
<p>我看到這段霸氣註解之後笑了一下XD</p>
<p>不過也多虧這個決定，這邊就有很多實作的細節都可以跳過。</p>
<p>基本上實作的程式碼大概可以分成三塊：</p>
<ul>
<li>剛開始連線時，會送出一些初始設定資訊</li>
<li>讓 server 其他部分調整一些基本設定</li>
<li>處理 client 送來的設定</li>
</ul>
<p>這邊可以發現主要都是在實作關於設定的通訊。其他像是處理 server 送出的畫面內容、如何處理 client 對於 PTT 的指令這些，就不是 telnet protocol 本身的工作。因此並沒有寫在這裡。</p>
<h3 id="起始設定"><a href="#起始設定" class="headerlink" title="起始設定"></a>起始設定</h3><p>一開始 server 會將一連串的設定訊息送給 client，client 收到後則會對每個訊息做出回應。PTT 送出的設定可以在 <code>telnet.c</code> 的 <code>telnet_init_cmds</code> 這個變數內找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> telnet_init_cmds[] = &#123;</div><div class="line">	 <span class="comment">// retrieve terminal type and throw away.</span></div><div class="line"> 	 <span class="comment">// why? because without this, clients enter line mode.</span></div><div class="line">	 IAC, DO, TELOPT_TTYPE,</div><div class="line">	 IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE,</div><div class="line"></div><div class="line">	 <span class="comment">// i'm a smart term with resize ability.</span></div><div class="line">	 IAC, DO, TELOPT_NAWS,</div><div class="line"></div><div class="line">	 <span class="comment">// i will echo.</span></div><div class="line">	 IAC, WILL, TELOPT_ECHO,</div><div class="line">	 <span class="comment">// supress ga.</span></div><div class="line">	 IAC, WILL, TELOPT_SGA,</div><div class="line">	 <span class="comment">// 8 bit binary.</span></div><div class="line">	 IAC, WILL, TELOPT_BINARY,</div><div class="line">	 IAC, DO,   TELOPT_BINARY,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中使用到的常數都定義在 <code>arpa/telnet.h</code> 中。這個檔案並不是 PTT 的一部分，而是大多數系統都會包含的標頭檔。上網搜尋一下就可以找到檔案。這些初始訊息翻譯成人話的話，意思大概如下 (以下每一行分別對應到上面一行)：</p>
<ul>
<li>現在來設定終端機種類吧 (TELOPT_TTYPE)</li>
<li>請給我終端機種類設定資訊</li>
<li>現在來設定終端機大小吧 (TELOPT_NAWS)</li>
<li>希望你能回應每個我傳送的訊息 (TELOPT_ECHO)</li>
<li>希望你能夠直接傳送下個訊息，而不要等我回覆 (TELOPT_SGA)</li>
<li>希望你能使用 8bit 傳輸模式 (TELOPT_BINARY)</li>
</ul>
<p>特別注意註解中有提到，若不送出前兩項設定訊息，client 可能就無法正確地顯示出 PTT 畫面。</p>
<h3 id="處理-client-設定訊息"><a href="#處理-client-設定訊息" class="headerlink" title="處理 client 設定訊息"></a>處理 client 設定訊息</h3><p>至於 client 這邊送回來的訊息，處理的方式基本上就是一個 finite state machine (FSM)。FSM 的概念就是程式會有一組狀態。每次收到訊號之後，檢查現在的狀態是甚麼，然後做出對應的動作，最後更新目前的狀態。詳細的部分各位有興趣可以自己去看，那段程式碼才大概 224 行，很快就可以看完。</p>
<p>大概需要注意的是，若收到 client 傳出的 <code>IAC SB</code> 訊息，那就會進入一個<strong>暫存</strong>狀態。接下來所有收到的訊息都會被放近一個 buffer 之中，直到收到 <code>SE</code> 指令為止。這個動作意義在於，<code>IAC SB</code> 是代表接下來收到的是關於某個選項的詳細資訊，例如選項若是 <code>TELOPT_NAWS</code>，那接下來就會收到終端機的長跟高的資訊。有趣的是，PTT 似乎只會對 <code>TELOPT_NAWS</code> 這個選項做出反應，其他的選項則大多都被忽略掉了。</p>
<h3 id="實際例子"><a href="#實際例子" class="headerlink" title="實際例子"></a>實際例子</h3><p>目前我用 Rust 撰寫的 <a href="https://github.com/SLMT/rust-ptt/tree/5246412a8ca514823c01e2cc40c4ee06d281e9cf" target="_blank" rel="external">PTT prototype</a> 已經可以送出前兩章看到的基本設定，以及接收 client 的訊息。</p>
<p>我使用 PCMan 來測試，發現 PCMan 在收到我的訊息後，會回傳下列訊息 (in bytes)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">255, 251, 24, 255, 250, 24, 0, 86, 84, 49, 48, 48, 255, 240, 255, 251, 31, 255, 250, 31, 0, 80, 0, 24, 255, 240, 255, 253, 1, 255, 253, 3, 255, 254, 0, 255, 252, 0</div></pre></td></tr></table></figure>
<p>若轉換為各自代表的意義，則大概是這樣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">IAC, WILL, TELOPT_TTYPE</div><div class="line">IAC, SB, &#123;TELOPT_TTYPE, TELQUAL_IS, 86, 84, 49, 48, 48, 255&#125;, SE</div><div class="line">IAC, WILL, TELOPT_NAWS</div><div class="line">IAC, SB, &#123;TELOPT_NAWS, width&#123;0, 80&#125;, height&#123;0, 24&#125;, 255&#125;, SE</div><div class="line">IAC, DO, TELOPT_ECHO,</div><div class="line">IAC, DO, TELOPT_SGA,</div><div class="line">IAC, DONT, TELOPT_BINARY,</div><div class="line">IAC, WONT, TELOPT_BINARY</div></pre></td></tr></table></figure>
<p>這邊可以看到像是對於 <code>TELOPT_NAWS</code> 這個選項，PCMan 送出了寬 80、高 24 的訊息。而 PTT 這邊就會依照他的請求來調整大小。其中有一個有趣的點是，PCMan 送出了他不會使用 8bit 模式的訊息。而 PTT 這邊則是看完之後就丟掉了。這感覺就像是以下發生了以下情境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PTT: 請使用 8-bit 模式</div><div class="line">PCMan: 我不能使用 8-bit 模式</div><div class="line">PTT: 哦，是哦。</div></pre></td></tr></table></figure>
<p>大概就是這樣吧XD</p>
<p>這邊了解之後，會先花點時間實作在 Rust-PTT 上，之後應該會進入 PTT 上關於 terminal 的實作。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>PTT Source Code - <a href="https://github.com/ptt/pttbbs" target="_blank" rel="external">https://github.com/ptt/pttbbs</a></li>
<li>我的 PTT Source Code 閱讀紀錄 - <a href="https://github.com/SLMT/pttbbs/tree/tracing" target="_blank" rel="external">https://github.com/SLMT/pttbbs/tree/tracing</a></li>
<li>Rust PTT Project - <a href="https://github.com/SLMT/rust-ptt" target="_blank" rel="external">https://github.com/SLMT/rust-ptt</a></li>
<li>PTT Source Code 中的 telnet.c - <a href="https://github.com/ptt/pttbbs/blob/master/common/sys/telnet.c" target="_blank" rel="external">https://github.com/ptt/pttbbs/blob/master/common/sys/telnet.c</a></li>
<li>RFC 854 - Telnet Protocol Specification - <a href="https://tools.ietf.org/html/rfc854" target="_blank" rel="external">https://tools.ietf.org/html/rfc854</a></li>
<li>PCMan - <a href="http://pcman.ptt.cc/" target="_blank" rel="external">http://pcman.ptt.cc/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本上，PTT 的使用者連上 PTT 時，都是透過一個叫做 telnet 的 protocol 進行。看了 PTT 的程式碼，會發現 PTT 並沒有使用其它的 telnet 函式庫，而是自行實作 telnet protocol。剛剛將這個部分看的差不多了，因此稍微紀錄一下實作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Research" scheme="http://www.slmt.tw/blog/categories/research/"/>
    
      <category term="PTT" scheme="http://www.slmt.tw/blog/categories/research/ptt/"/>
    
      <category term="Source Code" scheme="http://www.slmt.tw/blog/categories/research/ptt/source-code/"/>
    
    
      <category term="code" scheme="http://www.slmt.tw/blog/tags/code/"/>
    
      <category term="tracing" scheme="http://www.slmt.tw/blog/tags/tracing/"/>
    
      <category term="ptt" scheme="http://www.slmt.tw/blog/tags/ptt/"/>
    
      <category term="bbs" scheme="http://www.slmt.tw/blog/tags/bbs/"/>
    
  </entry>
  
  <entry>
    <title>PTT Source Code 研究筆記 1</title>
    <link href="http://www.slmt.tw/blog/2016/07/31/tracing-ptt-note-1/"/>
    <id>http://www.slmt.tw/blog/2016/07/31/tracing-ptt-note-1/</id>
    <published>2016-07-31T13:15:04.000Z</published>
    <updated>2017-08-04T06:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直有打算要研究 PTT 的程式碼。剛好近期也在學習 Rust 語言，因此起了想要使用 Rust 重寫 PTT 的想法。Rust 具有的許多特性我認為都很適合用來寫 PTT。因此開始進行了「用 Rust 重寫 PTT 計畫」。詳細的程式碼會一一更新在 Github 上的這個 <a href="https://github.com/SLMT/rust-ptt" target="_blank" rel="external">repository</a>。</p>
<p>另外，撰寫之前也需要先了解 PTT 的程式碼在做些甚麼，所以我必須要先讀懂原本的程式碼是如何運作的。我會將閱讀程式碼的筆記紀錄在我所 fork 的 PTT repository 之中的 <a href="https://github.com/SLMT/pttbbs/tree/tracing" target="_blank" rel="external">tracing branch</a> 內。</p>
<a id="more"></a>
<p>到現在為止，我已經閱讀了 <a href="https://github.com/ptt/pttbbs" target="_blank" rel="external">PTT Source Code</a> 之中，最主要的 <code>mbbsd.c</code> 這個檔案大多數的內容。<code>mbbsd.c</code> 這個檔案具有 <code>main</code> 函式，是程式的進入點，因此從這裡看起。</p>
<p>光是看到我目前為止的內容，就覺得當時寫這個 BBS 的人真的非常厲害。因為以當時的時代背景來說，幾乎沒有甚麼 library 可以使用。需要甚麼輔助功能就要自己寫。我看到了他們自己撰寫了顯示的功能，自己實作了 telnet protocol 等等。然後對系統，特別是 linux，內各個 API 都要瞭若指掌，才能掌握 BBS 站需要的功能。從這些就可以看出要搞出 BBS 站是多麼的不容易。</p>
<p>之後這些文章會紀錄我在閱讀程式碼時，注意到的一些我覺得值得紀錄的事情。</p>
<h2 id="Shared-Memory-amp-Multi-processes"><a href="#Shared-Memory-amp-Multi-processes" class="headerlink" title="Shared Memory &amp; Multi-processes"></a>Shared Memory &amp; Multi-processes</h2><p>第一個引起我注意的是，PTT 使用了 multi-processes 的方式來撰寫，而不是 multi-threading。因為我只有在修 Operating System 的時候使用過 <code>fork()</code>(產生 child process 的函式)，在這之後都是寫 multi-threading 的程式。因此我對 PTT 選擇了 fork 的做法很感興趣。</p>
<p>使用 fork 其實有不少好處，像是產生出來的 process 與原本的 process 是兩個獨立的個體。以資訊安全上的觀點來說，避免使用 shared memory 可以減少不同用戶之間的資料被竊取的可能性。不過，PTT 內其實大量使用了 shared memory (至少我目前看起來是這樣)，因此我覺得應該不是因為資訊安全的原因而做。看起來比較可能是因為 fork-based 的寫法比較容易撰寫與維護。另外，早期 thread 的 API 似乎還沒有一個穩定的標準，所以開啟一個 thread 也許也沒有現在這麼容易。</p>
<p>直覺上若使用了 multi-processes 的寫法，應該會使用 message passing 的方式來互相傳遞資料。不過 PTT 採用了跨 process 之間的 shared memory 來共享資訊。這也讓我挺訝異的，因為這也跟我的直覺不太符合。這邊我比較感興趣的是，不知道他們是怎麼處理不同 process 之間同時使用相同資料的問題，之後看到這部分會再另外撰寫筆記。</p>
<h2 id="偵測-Loading"><a href="#偵測-Loading" class="headerlink" title="偵測 Loading"></a>偵測 Loading</h2><p>每當有一個使用者連上 PTT 伺服器，PTT 的程式碼就會做一個系統負載檢查。若偵測到負載過高，就會送出「系統過載」的訊息。這邊我學到了如何檢查系統的負載量。</p>
<p>PTT 檢查的方式主要是透過 <code>getLoadavg()</code> 以及查看 <code>/proc/loadavg</code> 檔案這兩種方式來進行。這邊在檢查之前會先看是哪種系統，如果是 FreeBSD 的話，就會使用前者。若是 Linux 的話，就會使用後者。有趣的是，若兩者都不是，就會跟你說「不知道」XD</p>
<p>根據這份<a href="http://linux.die.net/man/3/getloadavg" target="_blank" rel="external">官方文件</a>，只要將一個陣列塞給 <code>getLoadavg()</code>，他就會將過去 1, 5, 15 分鐘的系統平均 loading 放到陣列之中。</p>
<p><code>/proc/loadavg</code> 則是一份 Linux 系統中的文件，每過一段時間會被更新一次。文件中的內容大概長這樣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0.20 0.18 0.12 1/80 11206</div></pre></td></tr></table></figure>
<p>前三個數字代表最近 1, 5, 10 分鐘的平均 loading，第四個數字代表正在執行與所有 processes 的數目，第五個代表目前最大的 process id。</p>
<p>目前 PTT 的程式碼只看最近 1 分鐘內的 loading，並且根據 <code>config.h</code> 之中 <code>MAX_CPULOAD</code> 的設定，來看目前系統是否過載。程式碼之中預設是超過 70% 就算是過載，不過實際上的設定也有可能會被改為其他數值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直有打算要研究 PTT 的程式碼。剛好近期也在學習 Rust 語言，因此起了想要使用 Rust 重寫 PTT 的想法。Rust 具有的許多特性我認為都很適合用來寫 PTT。因此開始進行了「用 Rust 重寫 PTT 計畫」。詳細的程式碼會一一更新在 Github 上的這個 &lt;a href=&quot;https://github.com/SLMT/rust-ptt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;repository&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，撰寫之前也需要先了解 PTT 的程式碼在做些甚麼，所以我必須要先讀懂原本的程式碼是如何運作的。我會將閱讀程式碼的筆記紀錄在我所 fork 的 PTT repository 之中的 &lt;a href=&quot;https://github.com/SLMT/pttbbs/tree/tracing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tracing branch&lt;/a&gt; 內。&lt;/p&gt;
    
    </summary>
    
      <category term="Research" scheme="http://www.slmt.tw/blog/categories/research/"/>
    
      <category term="PTT" scheme="http://www.slmt.tw/blog/categories/research/ptt/"/>
    
      <category term="Source Code" scheme="http://www.slmt.tw/blog/categories/research/ptt/source-code/"/>
    
    
      <category term="code" scheme="http://www.slmt.tw/blog/tags/code/"/>
    
      <category term="tracing" scheme="http://www.slmt.tw/blog/tags/tracing/"/>
    
      <category term="ptt" scheme="http://www.slmt.tw/blog/tags/ptt/"/>
    
      <category term="bbs" scheme="http://www.slmt.tw/blog/tags/bbs/"/>
    
  </entry>
  
  <entry>
    <title>「Hacking - The Art of Exploitation」閱讀筆記 - 第一章</title>
    <link href="http://www.slmt.tw/blog/2016/07/24/hacking-the-art-of-exploitation-1/"/>
    <id>http://www.slmt.tw/blog/2016/07/24/hacking-the-art-of-exploitation-1/</id>
    <published>2016-07-23T17:37:17.000Z</published>
    <updated>2017-08-04T06:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算開始好好來鑽研一下駭客的技術。雖然我一直對這塊抱持著很高的興趣，但是一直沒有好好研究這方面的知識。之前有稍微打打看一些簡單的 CTF，不過一直遭遇各種挫折XD 後來因為開始忙著要弄研究方面的東西，所以這件事就被我擱置了。最近去了美國一趟，在當地的書店發現了「Hacking - The Art of Exploitation」這本書。稍微翻一下之後覺得不錯，所以這次回來之後就要來好好看看。</p>
<a id="more"></a>
<p>為了要鞭策我閱讀這本書，我打算要每閱讀完一章後，寫一份閱讀筆記。這次就先從簡單的第一章開始。</p>
<h2 id="第一章-簡介"><a href="#第一章-簡介" class="headerlink" title="第一章 - 簡介"></a>第一章 - 簡介</h2><p>想當然爾，第一章不外乎就是在介紹書中的內容或者提醒讀者一些基本知識。這本書則是花費這一章來好好介紹一下「駭客」到底是甚麼。</p>
<p>以下來簡單總結一下這章的內容。</p>
<h3 id="駭客思維"><a href="#駭客思維" class="headerlink" title="駭客思維"></a>駭客思維</h3><p>有趣的是，這本書一開始提出了一個簡單的數學問題，來讓大家對駭客的思維有些感覺。題目如下 (以原文的方式呈現)：</p>
<blockquote>
<p>Use each of the numbers 1, 3, 4, and 6 exactly once with any of the four basic math operations (addition, subtraction, multiplication, and division) to total 24. Each number must be used once and only once, and you may define the order of operations; for example, 3 * (4 + 6) + 1 = 31 is valid, however incorrect, since it doesn’t total 24.</p>
</blockquote>
<p>簡單來說，題目給你 1, 3, 4, 6 四個數字，他希望你用這四個數字加上基本的加減乘除來組合出 24 的結果。</p>
<p>這題我花了點時間思考一下，不過我沒有想到答案 (〒︿〒)</p>
<p>最後正確答案是 <code>6 / (1 - 3 / 4)</code>。</p>
<p>這個答案符合題目的規則，但是一般人通常不會往分數的方向去思考，因此很難想到要用 <code>3 / 4</code>。</p>
<p>這本書用這個題目引出了駭客的思維：駭客通常就是一群會遵守著系統規則去尋找答案的人，但是他們會跳脫原本的框架，使用非直覺的方式來解答。</p>
<p>我個人很喜歡這種解釋方式，讓我覺得駭客很像是在程式上玩藝術的一群人。</p>
<h3 id="Hacker-與-Cracker"><a href="#Hacker-與-Cracker" class="headerlink" title="Hacker 與 Cracker"></a>Hacker 與 Cracker</h3><p>另外，第一章也強調了駭客 (Hacker) 與破壞者 (Cracker) 的不同。書中認為駭客是一群追求知識以及推廣自由知識的人們，破壞者則是拿駭客的工具去搞破壞、偷竊他人資訊的一群人。不過許多報章雜誌常會將這兩種人都統稱為駭客。這對遵守規則的人駭客們是很不公平的。</p>
<p>我個人也認同這點。大眾對駭客 (Hacker) 這個名詞一直有錯誤的概念。覺得駭客就是要去入侵系統，然後竊取人家的個資這樣。因此書中特別提出這點，想要先矯正讀者的觀念。</p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這章其他的部分則是大概介紹一下這本書中的程式碼使用方法，以及駭客的一些歷史等等。</p>
<p>雖然這章只是一個開頭而已，不過一開始的題目倒是讓我有些收穫。如果要成為駭客的話，那就不能依照常理的思路來思考。</p>
<p>不知道一直習慣這樣想的我，是否也有辦法成為駭客呢XD</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近打算開始好好來鑽研一下駭客的技術。雖然我一直對這塊抱持著很高的興趣，但是一直沒有好好研究這方面的知識。之前有稍微打打看一些簡單的 CTF，不過一直遭遇各種挫折XD 後來因為開始忙著要弄研究方面的東西，所以這件事就被我擱置了。最近去了美國一趟，在當地的書店發現了「Hacking - The Art of Exploitation」這本書。稍微翻一下之後覺得不錯，所以這次回來之後就要來好好看看。&lt;/p&gt;
    
    </summary>
    
      <category term="Hacking" scheme="http://www.slmt.tw/blog/categories/hacking/"/>
    
      <category term="Books" scheme="http://www.slmt.tw/blog/categories/hacking/books/"/>
    
      <category term="The Art of Exploitation" scheme="http://www.slmt.tw/blog/categories/hacking/books/the-art-of-exploitation/"/>
    
    
      <category term="hacker" scheme="http://www.slmt.tw/blog/tags/hacker/"/>
    
      <category term="hacking" scheme="http://www.slmt.tw/blog/tags/hacking/"/>
    
      <category term="note" scheme="http://www.slmt.tw/blog/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>2016 美國行 見聞筆記</title>
    <link href="http://www.slmt.tw/blog/2016/07/05/sigmod-2016-travel-notes/"/>
    <id>http://www.slmt.tw/blog/2016/07/05/sigmod-2016-travel-notes/</id>
    <published>2016-07-05T08:36:39.000Z</published>
    <updated>2017-08-04T06:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>6/19 ~ 7/5 這段期間我前往美國進行了為期兩個多禮拜的旅行，主要目的是參加 SIGMOD 2016 學術會議，次要目的則是到美國去玩。(但是實際上花的時間是玩比較多XD)</p>
<p>因為這次是我第一次去美國，觀察到很多有趣的事情。因此特別將觀察到的事物紀錄在這篇文章之中，讓沒有機會去美國，或者將要去美國的人可以參考看看。</p>
<p>關於 SIGMOD 2016 會議的心得與見聞之後會寫在另一篇文章中。</p>
<a id="more"></a>
<h2 id="旅遊路徑"><a href="#旅遊路徑" class="headerlink" title="旅遊路徑"></a>旅遊路徑</h2><p>首先先用一張圖來展示一下我們的旅遊路線 (請從左上角的藍點出發)：</p>
<p><a href="route.png" target="_blank"><img src="route.png"></a></p>
<p>以下詳細列出我們經過的地點：</p>
<ul>
<li>第一天：桃園國際機場 -&gt; 坐 11 小時飛機 -&gt; 舊金山國際機場 (SFO) -&gt; 住 SFO 附近的旅館</li>
<li>第二天：舊金山 (San Francisco) -&gt; 山景城 (Mountain View) Google 總部 -&gt; 庫帕提諾 (Cupertino) Apple 總部 -&gt; 史丹佛大學 (Stanford University) -&gt; 在 奧克荷斯特 (Oakhurst) 的旅館住宿</li>
<li>第三天：奧克荷斯特 (Oakhurst) -&gt; 優勝美地國家公園 (Yosemite National Park) -&gt; 莫諾湖 (Mono Lake, 我們又叫它單聲道湖) -&gt; 在 馬麥斯湖 (Mammoth Lakes) 的旅館住宿</li>
<li>第四天：馬麥斯湖 (Mammoth Lakes) -&gt; 進入內華達州 (State of Nevada) -&gt; 六小時左右車程 -&gt; 拉斯維加斯 (Las Vegas) -&gt; 看秀 -&gt; 在當地住宿</li>
<li>第五天：拉斯維加斯 (Las Vegas) -&gt; 進入亞利桑納州 (State of Arizona) -&gt; 西大峽谷 (Grand Canyon West) -&gt; 胡佛水壩 (Hoover Dam) -&gt; 拉斯維加斯 (Las Vegas)</li>
<li>第六天：拉斯維加斯 (Las Vegas) -&gt; 槍店打靶 -&gt; 進入加州 (State of California) -&gt; 洛杉磯 (Los Angeles) -&gt; 在好萊塢附近住宿</li>
<li>第七天：好萊塢附近 -&gt; 環球影城 (University Studio) -&gt; 回到旅館</li>
<li>第八天：旅館 -&gt; 長灘 (Long Beach) -&gt; 愛荷華級戰艦博物館 (Iowa Battleship Museum) -&gt; 聖莫尼卡 (Santa Monica) -&gt; 洛杉磯聯合車站 (Los Angeles Union station) -&gt; 搭八小時夜間班車回舊金山</li>
<li>第九天：下車 -&gt; 搭公車前往市區 -&gt; 將行李寄放在旅館 -&gt; 聯合廣場 (Union Square) -&gt; 回到旅館</li>
<li>第十天～第十二天：SIGMOD 2016 會議</li>
<li>第十三天：旅館 -&gt; 惡魔島 (Alcatraz Island) -&gt; 逛 39 號碼頭 (Pier 39) -&gt; 在舊金山市區內亂晃 -&gt; 回到旅館</li>
<li>第十四天：旅館 -&gt; 前往舊金山購物城 (San Francisco Premium Outlets) -&gt; 回到旅館</li>
<li>第十五天：旅館 -&gt; 舊金山市政中心 (Civic Center) -&gt; 延市場街 (Market Street) 一路逛到碼頭 -&gt; 渡輪大厦 (Ferry Building) -&gt; 反向逛回旅館 -&gt; 到 SFO 準備搭飛機回台灣</li>
</ul>
<h2 id="觀察"><a href="#觀察" class="headerlink" title="觀察"></a>觀察</h2><p>以下採用條列式的方式列出了我所觀察到的一些特點。若未來我有想到其他的，可能會再補充上去。</p>
<h3 id="整體"><a href="#整體" class="headerlink" title="整體"></a>整體</h3><ul>
<li>美金 100 元很難用，因為太大張很少店願意收</li>
<li>超商或餐廳大多數的飲料都是碳酸飲料或能量飲料，茶通常只有檸檬紅茶或奇怪的調味茶，不容易買到日式綠茶</li>
<li>美國平常能吃到的最低價餐點為速食，價格通常不會低於 5 USD，一般在 10 USD 左右</li>
<li>薯條為最常出現的主食</li>
<li>美國大眾交通運輸沒有很方便，若要進行離開城市的旅行，最好租車來開</li>
<li>人行紅綠燈與台灣很不同。不能行進的時候，雖然跟台灣一樣會顯示紅色的號誌。但是可以行進的時候，會先變成白色號誌，再轉變成紅色手掌搭配倒數計時。一般台灣人看到紅色手掌會以為是不能前進的意思，但是搭配倒數計時則其實是可以通行的。</li>
<li>Wifi 普及率算高，但是大多數網速都很慢</li>
<li>基本上在美國，有人服務到你包括桌邊點餐、搬行李、整理房間等等行為都要給小費 (Tips)。金額隨行為不同而變。整理房間通常 1~3 USD，吃飯則有人說給 10%，有人說給 18%，後者似乎比較多人講。</li>
<li>美國刷卡有種先刷卡再填入金額交易的行為。通常台灣都是先看好多少錢，再刷卡簽名。但是美國是先刷卡，然後在請款單上寫上小費與總金額之後再簽名。</li>
</ul>
<h3 id="優勝美地國家公園"><a href="#優勝美地國家公園" class="headerlink" title="優勝美地國家公園"></a>優勝美地國家公園</h3><p><a href="yosemite.jpg" target="_blank"><img src="yosemite.jpg"></a></p>
<ul>
<li>Glacier point 可以開車上去，但是要盡量在早上 10 點以前上去，不然人多就會開始管制車輛進出。</li>
<li>Yosemite Valley 內雖然有很多停車場，但是很容易停滿。若想停那邊就同樣也要很早去。我們當時是去完 Glacier Pointer 再下來，結果我們巡完 Valley 內所有停車場完全找不到任何位置。</li>
</ul>
<h3 id="Las-Vegas"><a href="#Las-Vegas" class="headerlink" title="Las Vegas"></a>Las Vegas</h3><p><a href="vegas.jpg" target="_blank"><img src="vegas.jpg"></a></p>
<ul>
<li>白天很熱</li>
<li>晚上也很熱，跟白天的差異只差在少了直曬的陽光，很有可能跟集中的水泥建築、沙漠地帶與持續排放熱氣的空調外機有關。熱的程度基本上就是熱到汗流出來馬上就會蒸發。</li>
<li>街道上有很多人在賣冰水，大多價格為 1 USD</li>
<li>高速公路的交流道非常複雜，而且幾乎快到閘道才會有告示牌通知前有閘道，如果沒有 Google 地圖或其他導航系統就很容易走錯</li>
<li>賭場要 21 歲以上才能進去，安全人員有權在任意時候要求查看 ID (身分證明, 外國人就看護照)。有些賭場會提供一個服務台，讓你在那邊查完 ID 之後取得一個手環。該手環可以證明你符合資格，安全人員就不會一直來煩你。</li>
</ul>
<h3 id="Los-Angeles"><a href="#Los-Angeles" class="headerlink" title="Los Angeles"></a>Los Angeles</h3><ul>
<li>儘管在夏天，天氣仍稍微偏涼，晚上可能最好穿件薄外套</li>
<li>高速公路上限速大概 65 miles/hr，但是大家都開到差不多 80 miles/hr</li>
<li>路上有人會發送光碟片，然後附上他的簽名，並表示他是知名藝人。當你接手光碟片後，就會要求你付錢購買，遇到這種情況要盡量避免接觸。</li>
<li>有很多很大的海灘</li>
</ul>
<h4 id="環球影城"><a href="#環球影城" class="headerlink" title="環球影城"></a>環球影城</h4><p><a href="universal.jpg" target="_blank"><img src="universal.jpg"></a></p>
<ul>
<li>遊樂設施（排除表演）之中，最好玩的應該是哈利波特的 4D 冒險</li>
<li>表演都很值得看，甚至應該先看表演再看是否有剩餘時間玩遊樂設施</li>
<li>就算中午才去，也可以把所有表演跟設施在閉園前玩完，因此其實不太需要一大早就去排隊</li>
</ul>
<h4 id="愛荷華級戰艦博物館"><a href="#愛荷華級戰艦博物館" class="headerlink" title="愛荷華級戰艦博物館"></a>愛荷華級戰艦博物館</h4><p><a href="iowa.jpg" target="_blank"><img src="iowa.jpg"></a></p>
<ul>
<li>上網買門票可以便宜 2 USD (19.95 USD =&gt; 17.95 USD)</li>
<li>戰艦很大，可以逛的區域很多，走完需要一點時間。走馬看花大概要半到一小時，仔細逛可以逛一整天</li>
</ul>
<h3 id="San-Francisco"><a href="#San-Francisco" class="headerlink" title="San Francisco"></a>San Francisco</h3><p><a href="sf.jpg" target="_blank"><img src="sf.jpg"></a></p>
<p><a href="sf_china.jpg" target="_blank"><img src="sf_china.jpg"></a></p>
<ul>
<li>雖然有很多華人，但大多數的華人都講廣東話，幾乎不會說普通話</li>
<li>公車非常多樣，有些是使用高架電纜，有些是輕軌，另外還有地下鐵與一般公車</li>
<li>街道上常會聞到有尿騷味</li>
<li>Union Square 以南有很多流浪漢和奇怪的人聚集</li>
<li>海邊很舒適，風景不錯</li>
<li>受到加利福尼亞洋流影響，夏天也非常冷，白天可能需要穿件長袖，晚上則冷到需要穿上外套</li>
<li>公車大概價格是 2.25 USD/人，通常買一張票後在該時間區段內都可以重複使用</li>
</ul>
<h4 id="SFO"><a href="#SFO" class="headerlink" title="SFO"></a>SFO</h4><ul>
<li>安檢比台灣嚴格多，例如鞋子也必須脫下來進行掃描，並且每個人都要進到一個小房間進行全身掃描。</li>
<li>候機處到處都有插頭可以使用，很方便</li>
</ul>
<h2 id="Fails"><a href="#Fails" class="headerlink" title="Fails"></a>Fails</h2><p>這邊列一些這次旅行沒有事先考慮清楚，而造成旅行不方便的一些點。</p>
<ul>
<li>沒有帶延長線，因為美國旅館的插頭都超級少，但是四個人一堆電器都要用電</li>
<li>沒有帶拖鞋，洗完澡後要出房門不太方便</li>
<li>帶太多 100 塊，因為很少店家會收，其他錢用完之後就很不方便</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6/19 ~ 7/5 這段期間我前往美國進行了為期兩個多禮拜的旅行，主要目的是參加 SIGMOD 2016 學術會議，次要目的則是到美國去玩。(但是實際上花的時間是玩比較多XD)&lt;/p&gt;
&lt;p&gt;因為這次是我第一次去美國，觀察到很多有趣的事情。因此特別將觀察到的事物紀錄在這篇文章之中，讓沒有機會去美國，或者將要去美國的人可以參考看看。&lt;/p&gt;
&lt;p&gt;關於 SIGMOD 2016 會議的心得與見聞之後會寫在另一篇文章中。&lt;/p&gt;
    
    </summary>
    
      <category term="Traveling" scheme="http://www.slmt.tw/blog/categories/traveling/"/>
    
      <category term="USA" scheme="http://www.slmt.tw/blog/categories/traveling/usa/"/>
    
    
      <category term="traveling" scheme="http://www.slmt.tw/blog/tags/traveling/"/>
    
      <category term="san francisco" scheme="http://www.slmt.tw/blog/tags/san-francisco/"/>
    
      <category term="sigmod" scheme="http://www.slmt.tw/blog/tags/sigmod/"/>
    
      <category term="usa" scheme="http://www.slmt.tw/blog/tags/usa/"/>
    
  </entry>
  
  <entry>
    <title>Rust 任天堂64 模擬器</title>
    <link href="http://www.slmt.tw/blog/2016/06/17/rust-nintendo64-emulator/"/>
    <id>http://www.slmt.tw/blog/2016/06/17/rust-nintendo64-emulator/</id>
    <published>2016-06-17T13:19:28.000Z</published>
    <updated>2016-07-04T06:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>先說不是我寫的XD</p>
<p>最近訂閱了 <a href="https://this-week-in-rust.org/" target="_blank" rel="external">This Week in Rust</a> 這個部落格上的文章。這個部落格會將每周關於 Rust 值得注意的事項整理成一篇文章，分享給大家。因為近期對 Rust 很有興趣，就訂閱了這個平台。</p>
<p>其中我看到了一個很有趣的 project。就是一位叫做 ferris 的網友，在 Twitch 上實況用 Rust 撰寫一個任天堂64 的模擬器。</p>
<a id="more"></a>
<p>一直以來我都沒有真正看過模擬器裡面的程式碼，而且我也沒有看過一個大型 Rust Project 的撰寫過程，因此對這個 project 就備感興趣。</p>
<p>目前最新才到 11 集，雖然我看了一集多還沒看到它載入第一個 instruction，不過目前為止讓我複習不少 Rust 語法，而且也學到了關於模擬器的一些基本知識。也許未來我也可以實況寫一個 Game Boy XD (寫任天堂64看起來很累)</p>
<p>有興趣的人可以追蹤它的 Twitter，或者到 Youtube 上看它的實況記錄，程式碼則可以在 Github 上找到：</p>
<p>Twitter - 追蹤 ferris：<a href="https://twitter.com/ferristweetsnow" target="_blank" rel="external">https://twitter.com/ferristweetsnow</a><br>Youtube - 實況記錄：<a href="https://www.youtube.com/playlist?list=PL-sXmdrqqYYcznDg4xwAJWQgNL2gRray2" target="_blank" rel="external">https://www.youtube.com/playlist?list=PL-sXmdrqqYYcznDg4xwAJWQgNL2gRray2</a><br>Github - 程式碼：<a href="https://github.com/yupferris/rustendo64" target="_blank" rel="external">https://github.com/yupferris/rustendo64</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先說不是我寫的XD&lt;/p&gt;
&lt;p&gt;最近訂閱了 &lt;a href=&quot;https://this-week-in-rust.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;This Week in Rust&lt;/a&gt; 這個部落格上的文章。這個部落格會將每周關於 Rust 值得注意的事項整理成一篇文章，分享給大家。因為近期對 Rust 很有興趣，就訂閱了這個平台。&lt;/p&gt;
&lt;p&gt;其中我看到了一個很有趣的 project。就是一位叫做 ferris 的網友，在 Twitch 上實況用 Rust 撰寫一個任天堂64 的模擬器。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://www.slmt.tw/blog/categories/programming/"/>
    
      <category term="Rust" scheme="http://www.slmt.tw/blog/categories/programming/rust/"/>
    
    
      <category term="rust" scheme="http://www.slmt.tw/blog/tags/rust/"/>
    
      <category term="programming" scheme="http://www.slmt.tw/blog/tags/programming/"/>
    
      <category term="emulator" scheme="http://www.slmt.tw/blog/tags/emulator/"/>
    
  </entry>
  
  <entry>
    <title>hexo-blog</title>
    <link href="http://www.slmt.tw/blog/2016/06/15/hexo-blog/"/>
    <id>http://www.slmt.tw/blog/2016/06/15/hexo-blog/</id>
    <published>2016-06-15T14:31:18.000Z</published>
    <updated>2016-07-04T06:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>我又換新部落格啦！這次 Static Pages Generator 改用 <a href="https://hexo.io/zh-tw/" target="_blank" rel="external">Hexo</a>，原因主要為：</p>
<ul>
<li>Hexo 以 Node.js 撰寫</li>
<li>Hexo 中文資源比較多可以參考 (使用者大多為華人)</li>
<li>Hexo 是台灣人 <a href="https://zespia.tw/" target="_blank" rel="external">Tommy Chen</a> 開發的</li>
</ul>
<h2 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h2><p>因為我一直都沒有自己很喜歡的主題，所以這次決定來自己寫一個。</p>
<p>這次主要的概念是簡單明瞭，又要 responsive。因此就製作出了現在看到的這個部落格風格。</p>
<p>如果想要參考我自己撰寫的程式碼，可以到我的 Github Repository 參考：</p>
<p><a href="https://github.com/SLMT/slmt-blog" target="_blank" rel="external">https://github.com/SLMT/slmt-blog</a></p>
<p>雖然這個風格很容易寫就是了XD</p>
<p>這個風格主要使用了以下這些 library：</p>
<ul>
<li><a href="http://purecss.io/" target="_blank" rel="external">Pure CSS</a> - 一個極輕量的 responsive library。主要是為了上面的 navigation bar。</li>
<li><a href="http://fontawesome.io/?utm_source=hackernewsletter" target="_blank" rel="external">Font Awesome</a> - 一個整合各種實用 icon 的字型。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我又換新部落格啦！這次 Static Pages Generator 改用 &lt;a href=&quot;https://hexo.io/zh-tw/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;，原因主要為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hexo 以
    
    </summary>
    
      <category term="Building Blog" scheme="http://www.slmt.tw/blog/categories/building-blog/"/>
    
      <category term="Hexo" scheme="http://www.slmt.tw/blog/categories/building-blog/hexo/"/>
    
    
      <category term="blog" scheme="http://www.slmt.tw/blog/tags/blog/"/>
    
      <category term="hexo" scheme="http://www.slmt.tw/blog/tags/hexo/"/>
    
      <category term="welcome" scheme="http://www.slmt.tw/blog/tags/welcome/"/>
    
      <category term="chinese" scheme="http://www.slmt.tw/blog/tags/chinese/"/>
    
  </entry>
  
  <entry>
    <title>BambooFox 第三堂社課心得</title>
    <link href="http://www.slmt.tw/blog/2015/10/30/bamboofox-club-03/"/>
    <id>http://www.slmt.tw/blog/2015/10/30/bamboofox-club-03/</id>
    <published>2015-10-29T16:00:00.000Z</published>
    <updated>2016-07-04T06:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>這次的課程接續上次組合語言的內容，主要在談 x86 架構下的組合語言，以及常見的 Buffer Overflow 漏洞。</p>
<a id="more"></a>
<h2 id="課程內容分享"><a href="#課程內容分享" class="headerlink" title="課程內容分享"></a>課程內容分享</h2><h3 id="組合語言"><a href="#組合語言" class="headerlink" title="組合語言"></a>組合語言</h3><p>一開始先回顧一下 x86 下的架構，包含 registers 與一些 conditional flags 等等。 接著複習了一些 x86 架構下常見的組合語言指令。 這邊有提到 Intel 與 AT&amp;T 兩種 style 不同的寫法，並介紹一些之間的差異等等。</p>
<p>最重要的資訊，我想應該就是了解如何做 system call 吧！</p>
<p>System call 是一種讓你程式跟作業系統 (Opearating System, OS) 溝通的管道。 舉凡要進行任何需要 OS 幫忙的工作，都要透過 system call。 而在組合語言之中，想要進行 system call，就要使用 interrept 的指令來暫時中斷程式，並轉交權限給 OS。 大概進行的 pattern 就如同下面所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mov		eax, xxx	; 想要 OS 執行的 function 代碼</div><div class="line">mov		ebx, xxx	; function 的第一個參數</div><div class="line">mov		ecx, xxx	; function 的第二個參數</div><div class="line">mov		edx, xxx	; function 的第三個參數</div><div class="line">...</div><div class="line"></div><div class="line">int		0x80		; 進行 system call</div></pre></td></tr></table></figure>
<p>一開始要先將一些參數存入 registers，<code>eax</code> 要放你想要 OS 進行的 system call function 代碼。 例如你想要系統讀檔，就要放 3 (sys_read)。 然後，其他 registers，像是 <code>ebx</code>, <code>ecx</code>, <code>edx</code>, <code>esx</code>, <code>edi</code> 則是要放呼叫該動作的參數。 例如剛剛說的讀檔，就必須要分別在 <code>ebx</code>、<code>ecx</code> 與 <code>edx</code> 放入 file descriptor、buffer pointer 與想要讀取的大小。 最後再執行 <code>int 0x80</code> 指令來進行 system call。</p>
<p>詳細每個 register 在進行 system call 所需要放的參數可以在 <a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html" target="_blank" rel="external">這個表</a> 找到。</p>
<p>我想學這個的目的，除了是為了要能夠對程式做逆向工程之外，也是為了要在之後 inject (注入) shellcode 而使用。 甚至是做更進一步的攻擊。 算是還挺實用的。</p>
<h3 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h3><p>Buffer overflow 是 C/C++ 常見的漏洞。 只要你的程式之中使用到了陣列或指標，並配合呼叫了不安全的 function，就有可能有潛在的問題。</p>
<p>例如下面這段 code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> input[<span class="number">50</span>];</div><div class="line"></div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, input);</div></pre></td></tr></table></figure>
<p>這段看起來極其平淡，且在一開始程設課就學過的 code，潛藏著極大的危機存在。</p>
<p><code>scanf</code> 不會檢查使用者輸入的長度，也不會知道 <code>input</code> 這個陣列有多大，除非遇到特定的字元，不然他就會持續性地一直讀取輸入值。 而當使用者輸入的長度超過了 <code>input</code> 的空間，也就是在上例中超過 49 個字元 (最後一個字是 <code>\0</code>)，就會發生 overflow 的情況。 一般來說 overflow 只會讓程式出現 <code>segmentation fault</code> 而已，可是有心人士可以利用這個來控制程式的運作方向。</p>
<p>區域變數通常是放在 stack 中，stack 除了變數之外，還會放著各式各樣其他的資訊。 像是 function arguments，stack frame pointer，還有最重要的 saved eip。 EIP 是 x86 系統下一個特殊的 register，這個 register 不能直接寫入，只能透過特殊指令來進行修改。 EIP 其重要之處，就是在他負責告訴 CPU，下一個要執行的指令在哪裡。</p>
<p>因此掌控了 EIP，就掌控了整個程式走向。</p>
<p>想想前面提到的 buffer overflow，到底多出的部分跑哪去了？基本上就是跑到外面的地方，覆蓋掉 stack 上的其他資訊。</p>
<p>剛剛提到了 stack 有放 saved eip。 當程式呼叫 function 的時候，為了要能夠在 function 結束之後，跳回到原本的位置，會將回去預計繼續執行的程式碼位址暫存在 stack 中，這就是 saved eip。</p>
<p>利用 buffer overflow，你就會有機會覆寫掉 saved eip 的數值。 只要控制得好，就能將你想要讓程式執行的程式碼位址覆蓋掉 saved eip。 當程式 return 的時候，就會拿出你預先設計的數值，並跳轉到你希望的位置繼續執行程式。 這個時候就可以做很多有趣的事情，例如讓程式執行你預先塞好的程式碼，然後呼叫 shell 等等。</p>
<p>這也是到現今為止還是常常能看見的大洞。 不過編譯器其實也有在進步，為了這防止駭客攻擊這個部分，使用了各式各樣的技巧來保護。 當然駭客也不是笨蛋，也想出了很多方法繞過這些機制。 到現在還沒有一定的勝負。</p>
<h2 id="練習題的收穫"><a href="#練習題的收穫" class="headerlink" title="練習題的收穫"></a>練習題的收穫</h2><p>今天主要的練習是 <a href="http://train.cs.nctu.edu.tw/problems/1" target="_blank" rel="external">這題</a> ，重點在於 buffer overflow 的觀念。 讓正確的 buffer overflow，找到如何覆蓋 saved eip，找到程式應該要執行到哪，以及要怎麼避免程式搗亂的行為。</p>
<p>這題今天學到最有用的知識有兩點：</p>
<h3 id="1-scanf-終止條件"><a href="#1-scanf-終止條件" class="headerlink" title="1. scanf 終止條件"></a>1. <code>scanf</code> 終止條件</h3><p>這題有個部分會檢查你輸入 buffer 的長度，檢查的方式是利用 <code>strlen</code>，並且會對你的 buffer 做攪亂的動作。 這邊我們可以讓程式只攪亂部分的 buffer，或甚至完全繞過。 重點在於讓程式以為 buffer 很短，但是其實比他知道的大很多。</p>
<p>但是要怎麼做呢？ <code>strlen</code> 的檢查中止條件是看到 <code>\0</code> 就停下來。 換句話說，<code>\0</code> 之前的內容都會被當作字串的一部分，之後的東西就不管了。 這邊我一開始有想到在 buffer 內插入 <code>\0</code> 來防止程式攪亂我的 payload。 但是我馬上想到了，<code>scanf</code> 應該會把 <code>\0</code> 也當作終止條件，所以我想這招應該沒用。</p>
<p>可是在卡了許久之後，經過前輩提示，看了看提示的投影片，才知道原來 <code>scanf</code> 的中止條件更狹隘。 他們只會在遇到空白或是換行字元才停，<code>\0</code> 也會被當成字串的一部分吃進來。 這還真是大洞啊！ 我完全意想不到這種我以為該有的條件竟然沒有！ 看來 C\C++ 比我想像的更危機四伏。</p>
<h3 id="2-cat"><a href="#2-cat" class="headerlink" title="2. cat -"></a>2. <code>cat -</code></h3><p>這個也很有趣。 他們的程式是放在他們專有的機器上執行，而我們必須要透過網路連線才有辦法跟程式溝通。 通常會使用 <code>nc</code> (netcat) 進行。 當攻擊者取得 shell 之後，就可以拿到機器上的 flag。 不過雖然我將 payload 送過去之後，也成功呼叫出 shell 了。 可是遇到了一個很大的問題，就是我無法跟 shell 進行互動！ 因為我使用了 <code>cat payload | nc [IP] [Port]</code> 的方式來將預先寫好的 input 傳過去，但是也封閉了我使用 <code>nc</code> 進行溝通的道路。</p>
<p>正當我在想是否要自己寫 python code 來互動的時候，發現了一個更簡單的方式！</p>
<p>就是使用 <code>cat -</code>！ <code>cat</code> 指令會印出檔案的內容，後面接著檔案名稱。 那 <code>-</code> 又是啥檔案？</p>
<p><code>-</code> 代表的就是 standard input！ 也就是標準輸入 (通常是鍵盤)！</p>
<p>如果你有自己的 unix 環境可以試試看，使用 <code>cat -</code> ，並輸入一些字元會發生甚麼事情。 你會發現它會將你輸入的東西直接 output 出來。</p>
<p>這就是我需要的啊！</p>
<p>我只要把上面的指令改成 <code>cat payload - | nc [IP] [Port]</code>。 這樣 <code>cat</code> 就會先將 payload 傳過去，然後再轉接 standrad input 給它。 這樣我就可以在取得 shell 之後，輸入指令給 <code>nc</code> 傳送了！</p>
<p>這個算是我今天覺得最有用的技巧XD</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這次的課程接續上次組合語言的內容，主要在談 x86 架構下的組合語言，以及常見的 Buffer Overflow 漏洞。&lt;/p&gt;
    
    </summary>
    
      <category term="CTF" scheme="http://www.slmt.tw/blog/categories/ctf/"/>
    
      <category term="BambooFox" scheme="http://www.slmt.tw/blog/categories/ctf/bamboofox/"/>
    
    
      <category term="bamboofox" scheme="http://www.slmt.tw/blog/tags/bamboofox/"/>
    
      <category term="ctf" scheme="http://www.slmt.tw/blog/tags/ctf/"/>
    
      <category term="club" scheme="http://www.slmt.tw/blog/tags/club/"/>
    
  </entry>
  
  <entry>
    <title>BambooFox 第二堂社課心得</title>
    <link href="http://www.slmt.tw/blog/2015/10/16/bamboofox-club-02/"/>
    <id>http://www.slmt.tw/blog/2015/10/16/bamboofox-club-02/</id>
    <published>2015-10-15T16:00:00.000Z</published>
    <updated>2016-07-04T06:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去了第二次交大 <a href="https://bamboofox.torchpad.com/" target="_blank" rel="external">BambooFox</a> 社課，這次內容主要在於 Reverse Engineering，以下紀錄了今天社課的要點。</p>
<a id="more"></a>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><p>這次大概有三個部分。第一部分是在檢討上一次社課留給學生的練習題，第二部分則是在分享一些常用的工具，最後則是今天的主軸，<strong>逆向工程</strong>。</p>
<p>如果各位想看投影片的話，只要到他們 <a href="https://bamboofox.torchpad.com/" target="_blank" rel="external">官網</a> 就可以找到每次社課的投影片以及錄影了。</p>
<h3 id="第一部分：練習題"><a href="#第一部分：練習題" class="headerlink" title="第一部分：練習題"></a>第一部分：練習題</h3><p>我在上一篇有提過，Python 的 <a href="https://docs.python.org/2/library/pickle.html" target="_blank" rel="external">pickle module</a> 存在著一個漏洞，會讓 object 在 deserialize 的時候執行預先設計好的程式碼。因此我們可以自己產生 serialize 後的 object，裡面插入我們想讓目標程式執行的程式碼。以達到取得目標機器上 shell 的目的。</p>
<p>各位如果有興趣的話，他們有把題目放到練習網站上，可以到下列網址玩玩看 (帳號可以免費申請)：</p>
<p><a href="http://140.113.194.85:3000/problems/8" target="_blank" rel="external">http://140.113.194.85:3000/problems/8</a></p>
<p>這邊我提兩個很重要的工具：</p>
<h4 id="NetCat"><a href="#NetCat" class="headerlink" title="NetCat"></a>NetCat</h4><p><code>nc</code> (NetCat) 是一個程式，linux 系統上面大多都有內建。它的功用是可以連到指定的 ip 與 port，並將使用者輸入的資料導向到目標伺服器上。然後把目標伺服器上回傳的結果導回我們的標準輸出 (通常是螢幕) 上。</p>
<p>這個東西真的很好用。以往如果我要跟一個伺服器溝通的話，都要寫一些程式來做 socket programming。可是有這東西的話，就完全不需要自己寫程式來做了！而且許多 CTF 競賽的程式都不是那種可以用像是 HTTP 或者 SSH Protocol 連上的東西，通常是單純以文字直接溝通的伺服器。因此 <code>nc</code> 就可以幫助你連上這種程式。</p>
<p>另外還有一點很重要的是， <code>nc</code> 不但可以主動連到其他伺服器，還可以被動式的開啟 socket 接收資料。這個功能也很常用！例如你利用某個漏洞進入了伺服器，但是你不一定可以看到你的程式碼的執行結果。這個時候就必須讓該伺服器把執行指令的結果，利用 <code>nc</code> 吐回你的機器上。而你的機器上就自然而然需要開啟一個 socket 接收資訊囉！</p>
<h4 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h4><p>上一篇文章也有提到 <a href="http://pwntools.com/" target="_blank" rel="external">pwntools</a>。這是一個專門用來打 CTF 用的 python module。</p>
<p>事實上，當你玩了一下這道題目之後，你大概會知道要怎麼取得 flag。可是接著很快就會發現，每個指令都要慢慢輸入真的是很麻煩。而且特別這題又有 RSA Key，慢慢複製輸入又會令人更不爽。所以你大概就會瞭解到這裡需要寫一個 script 來自動化整個過程。</p>
<p>pwntools 提供了很多方便的 function 來幫助你建立自動化的 script，目前最需要知道的就是 <code>send</code> 跟 <code>recvuntil</code>。用法可以查查 bamboofox 上一次社課的投影片，或者看看官方的說明文件。</p>
<h3 id="第二部分：分享常用工具"><a href="#第二部分：分享常用工具" class="headerlink" title="第二部分：分享常用工具"></a>第二部分：分享常用工具</h3><p>這邊稍微介紹了一下電腦執行程式的架構，為下一部份舖梗。另外介紹了一些工具，主要是 vim 與 tmux。</p>
<p>這兩者的教學網路上很多，這邊就不贅述了。Google 一下就可以看到不少資源。我個人特別推 tmux，真的是很方便的工具。我因為研究的關係時常使用。如果你想要在同一個 terminal 上開多個分割視窗，或者你想要與伺服器中斷連線後，下一次進去能可以看到上一次的工作狀態，那 tmux 絕對是你的好選擇！</p>
<h3 id="第三部分：逆向工程"><a href="#第三部分：逆向工程" class="headerlink" title="第三部分：逆向工程"></a>第三部分：逆向工程</h3><p>逆向工程是今天最主要的內容。不過重點大概就以下幾點：</p>
<ol>
<li>x86 系統架構</li>
<li>Intel x86 組合語言</li>
<li><a href="https://www.hex-rays.com/products/ida/" target="_blank" rel="external">IDA Pro</a> 的使用方式</li>
</ol>
<p>另外還有講一個叫做 Immunity Debugger 的工具，不過我那部份聽得沒有很懂，而且後來也沒用到，所以這邊也就不提了。</p>
<h4 id="組合語言"><a href="#組合語言" class="headerlink" title="組合語言"></a>組合語言</h4><p>這段的目標在於分析一個程式的行為。最直接的辦法就是把程式反組譯 (disassembly)，然後看看他的程式碼是怎麼跑的。反組譯得到的程式碼不會是 C 語言，而是很接近 CPU 執行方式的組合語言 (Assembly Language)。組合語言沒有 C 語言那麼容易看懂，而且隨著不同架構，組合語言的語法也會有些微不同。幸好大多數的概念都差不多，因此學過一種之後，其他種類也不會太難上手。</p>
<p>我之前在 PicoCTF 2013 有看過一本書，寫得還不錯，而且淺顯易懂。這邊將他們官方提供的電子版放在 <a href="https://2013.picoctf.com/docs/asmhandout.pdf" target="_blank" rel="external">這裡</a> 讓各位下載。下載下來一看之後會發現頁數還不少，不過我覺得也不需要全部看完。大概前面三分之一看懂就好。後面的東西只要快速把各種指令看看就好。甚至可以也都不看後面的東西，等到真正遇到的時候再去查就好。</p>
<h4 id="IDA-Pro"><a href="#IDA-Pro" class="headerlink" title="IDA Pro"></a>IDA Pro</h4><p>IDA Pro 是一個逆向工程的常用工具。這個工具到官網上可以抓到免費版，雖然功能有些殘缺，但是也大致夠用。大概你會發現最缺的功能就是不能看 64bit 的程式，不過除此之外都還好。</p>
<p>這個工具會幫你將程式轉為組合語言給你看，並且幫你建立一些 flow chart，以方便掌握程式的執行脈絡。事實上，以前我就有稍微用過這個程式，不過老實說一開始我也不知道該從哪裡看起。主要是因為通常程式反組譯之後得到的程式碼都非常多，第一眼看到就眼花撩亂。因此他們今天上課就提到，其實可以從 <code>.string</code> 視窗開始研究。</p>
<p><code>.string</code> 視窗列出了這個程式被預先填入的字串常數。因為字串本來就是要顯示給使用者看的，所以字串都會完完整整地存在程式的某個位置。而這個時候，你就可以先看那些字串跟你要找的東西相關。例如你今天可能要找驗證密碼的程式碼，那這時候如果你看到了 <code>Sorry, password is wrong</code>，你大概就可以知道這段話一定跟你要找的程式碼有關。IDA Pro 還有個很方便的功能，就是會幫你標出字串在哪段程式碼被使用到，因此你就可以跳到那段程式碼，來看看他是怎麼驗證的。</p>
<p>其他還有像是，會幫你標出 function 內的區域變數，另外也可以幫區塊與變數重新命名等等。善用的話就可以大大幫助逆向工程。</p>
<h4 id="轉換成-C-Code"><a href="#轉換成-C-Code" class="headerlink" title="轉換成 C Code"></a>轉換成 C Code</h4><p>就算已經會組合語言，也會使用 IDA Pro，真正看下去的時候也不一定能很快上手。這邊有個很重要的概念在於，你要知道那些 C 語言的程式碼轉換後會變成甚麼樣的組合語言。今天上課他們有稍微提到常見的迴圈和 function call 會大概變成甚麼樣子。如果有稍微記得的話，對還原成 C 的時候會很有幫助。詳情也可以看看他們的投影片。</p>
<p>再來，就是要知道一些組合語言的潛規則。像是當你看到了下面這段程式碼：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">push ...</div><div class="line">push ...</div><div class="line">push ...</div><div class="line">call ...</div></pre></td></tr></table></figure>
<p>也就是一堆 <code>push</code> 之後接著一個 <code>call</code>，這其實就是在呼叫 function。<code>push</code> 將呼叫 function 的參數存入 stack，<code>call</code> 則是在讓程式的執行跳轉到 function 的程式碼執行。</p>
<p>而且事實上，並不是所有呼叫 function 的程式碼都長這樣，有的則是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov    %eax,0x4(%esp)</div><div class="line">mov    %ebx,(%esp)</div><div class="line">call   ...</div></pre></td></tr></table></figure>
<p><code>%eax</code>、<code>%ebx</code>、<code>%esp</code> 都是 register。Register 是 CPU 之中用來暫存資料的空間。其中 <code>%esp</code> 代表的是 stack 最頂層的位置。這一連串的 <code>mov</code> 動作其實就等同於 <code>push</code>，只是 <code>push</code> 會移動 <code>%esp</code>，<code>mov</code> 不會移動。所以這一段程式碼其實跟上一段是差不多的行為。可是沒看過就會覺得怎麼怪怪的。</p>
<p>又或者你要知道，通常 function return 的時候，會把 return value 塞在 <code>%eax</code> 裡面。因此時常在某些 function 回來之後，就會看到程式碼取出 <code>%eax</code> 的值做其他事情。</p>
<p>很多規則都是需要多看幾次或者上網查過才會知道的。</p>
<p>最後最重要的是，耐心。程式碼一多起來看了就會很煩，所以一定要仔細地慢慢看。我個人會一邊看一邊試著把組語還原成 C 的程式碼，這樣我最後才能整理出這個程式的邏輯到底是如何。</p>
<h4 id="逆向工程練習題"><a href="#逆向工程練習題" class="headerlink" title="逆向工程練習題"></a>逆向工程練習題</h4><p>逆向工程的部分他們也有提供練習題，有興趣的可以玩玩看：</p>
<ul>
<li>Windows 程式題：<a href="http://140.113.194.85:3000/problems/18" target="_blank" rel="external">http://140.113.194.85:3000/problems/18</a></li>
<li>Linux 程式題：<a href="http://140.113.194.85:3000/problems/19" target="_blank" rel="external">http://140.113.194.85:3000/problems/19</a></li>
</ul>
<p>以上這幾題我都解出來了，如果想要討論的話可以留言討論XD</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天去了第二次交大 &lt;a href=&quot;https://bamboofox.torchpad.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BambooFox&lt;/a&gt; 社課，這次內容主要在於 Reverse Engineering，以下紀錄了今天社課的要點。&lt;/p&gt;
    
    </summary>
    
      <category term="CTF" scheme="http://www.slmt.tw/blog/categories/ctf/"/>
    
      <category term="BambooFox" scheme="http://www.slmt.tw/blog/categories/ctf/bamboofox/"/>
    
    
      <category term="bamboofox" scheme="http://www.slmt.tw/blog/tags/bamboofox/"/>
    
      <category term="ctf" scheme="http://www.slmt.tw/blog/tags/ctf/"/>
    
      <category term="club" scheme="http://www.slmt.tw/blog/tags/club/"/>
    
  </entry>
  
  <entry>
    <title>BambooFox 第一堂社課心得</title>
    <link href="http://www.slmt.tw/blog/2015/10/02/bamboofox-club-01/"/>
    <id>http://www.slmt.tw/blog/2015/10/02/bamboofox-club-01/</id>
    <published>2015-10-01T16:00:00.000Z</published>
    <updated>2016-07-04T06:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去參加了交大 <a href="https://bamboofox.torchpad.com/" target="_blank" rel="external">BambooFox</a> 的第一堂社課，收穫不少。因此我想寫下一些參與的心得，並記錄一些學習到的技巧。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其實很早以前我就一直對資訊安全方面的東西有興趣，最早可以追朔到我國中的時候，不過當時並不具備相關的知識。後來到大學之前，也有購買一些相關書籍。可惜大多數的書都只是教如何使用一些滲透軟體，技術面的東西對我來說又太深。最後就沒有繼續研究。</p>
<p>上大學後，開始學習程式語言與各種撰寫技巧，逐漸具備各式各樣的知識。最近想起了當年小時候對這塊的興趣。雖然現在已經是再一年就要脫離學生生活的碩二生，但是還是希望在這最後學期能夠真正地好好學好這些東西。</p>
<p>當然在這之前也並非沒有研究，只是因為無人指導，也不知道該從哪裡開始。直到今年參加了 <a href="http://hitcon.org/" target="_blank" rel="external">HITCON</a> (台灣駭客年會)，才開始對這塊有初步的認識。在會中聽說交大今年要成立相關社團，而清大一直都沒有這種社團，所以我當然就很興奮地過去參加啦！</p>
<h2 id="課程內容"><a href="#課程內容" class="headerlink" title="課程內容"></a>課程內容</h2><p>今天的課程內容主要涵蓋兩個部分，基本 <strong>Linux Shell 操作</strong> 與 <strong>Python 基礎</strong>。</p>
<h3 id="Linux-Shell-操作"><a href="#Linux-Shell-操作" class="headerlink" title="Linux Shell 操作"></a>Linux Shell 操作</h3><p>基本 Linux Shell 操作我其實算是挺熟悉了，畢竟平常實驗室的實驗都是在 CentOS 上跑，還寫過一點 bash script。而且網路上的資源也非常豐富，其中繁體中文資源以「<a href="http://linux.vbird.org/" target="_blank" rel="external">鳥哥的Linux 私房菜</a>」最為有名。不過還是有兩點值得一提的東西。</p>
<h4 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p><a href="https://www.kali.org/" target="_blank" rel="external">Kali Linux</a> 是 Linux 的其中一個分支，主要是基於 Debian 開發的作業系統。這個系統的特點在於，它具有大量的滲透測試工具，並提供了許多支援，因此成為了駭客們愛用的系統。HITCON 會場也可以看到許多人都在使用。</p>
<p>基本上這個系統確實非常方便，甚至對很多人來說都是不可或缺的工具。不過操作上跟一般的 Linux 系統沒甚麼太大的差別，所以也不會太難上手。</p>
<h4 id="特殊-Bash-指令"><a href="#特殊-Bash-指令" class="headerlink" title="特殊 Bash 指令"></a>特殊 Bash 指令</h4><p>Shell 的使用算是學習 Linux 很重要的基礎，一般的操作很快就可以上手。不過很不錯的是，他們有教一些進階與特殊的用法。舉個例子來說，在 Bash 中使用 <code>$(...)</code>，其中包含的指令就是會被執行，而輸出的東西則會變成變數。然後 <code>$0</code> 這個變數通常指向 <code>bash</code>。因此如果你讓某些程式，執行了以下這個指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$($0)</div></pre></td></tr></table></figure>
<p>就會啟動 shell，讓別人可以為所欲為。(有興趣的人可以用 C 的 <code>system()</code> 或 python 的 <code>os.system()</code> 執行看看)</p>
<p>這個指令的特點在於沒有使用到任何 <code>bash</code> 或 <code>sh</code> 的字樣就啟動了 shell，這樣就可以越過某些過濾式的檢查。</p>
<h3 id="Python-基礎"><a href="#Python-基礎" class="headerlink" title="Python 基礎"></a>Python 基礎</h3><p>老實說，我對 python 幾乎一竅不通。最近才開始遵循 <a href="http://learnpythonthehardway.org/" target="_blank" rel="external">Learn Python The Hard Way</a> 的教學開始入門。今天社課教了不少基礎用法，讓大家快速上手。值得提的是，他們有介紹到一個叫做 <a href="https://www.hackerrank.com/" target="_blank" rel="external">Hacker Rank</a> 的網站，可以讓大家練習 Python。</p>
<p>另一點值得講的，他們介紹了一個好用的 Pyhton Module，<a href="http://pwntools.com/" target="_blank" rel="external">Pwntools</a>。這個工具是專門為 CTF (Capture The Flag) 比賽設計的 module，裡面包含了許多好用的 Python function，讓大家可以快速撰寫出針對某漏洞設計的 Python script。今天我也在之後的練習之中體會到了好處。</p>
<h2 id="課後練習"><a href="#課後練習" class="headerlink" title="課後練習"></a>課後練習</h2><p>他們除了上課之外，還很用心地準備了一個練習題給大家測試。這個練習題主要是來自於 Python 的 <a href="https://docs.python.org/2/library/pickle.html" target="_blank" rel="external">pickle module</a> 的漏洞。以下解釋一下這個漏洞。</p>
<p>首先可以先看這段程式碼，有興趣的人可執行看看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pickle, os</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exploit</span><span class="params">(object)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></div><div class="line">		comm = <span class="string">"sh"</span></div><div class="line">		<span class="keyword">return</span> (os.system, (comm,))</div><div class="line"></div><div class="line">a = pickle.dumps(Exploit())</div><div class="line">b = pickle.loads(a)</div></pre></td></tr></table></figure>
<p>執行後會發現這段程式碼會啟動 shell，為什麼呢？</p>
<p>在解釋之前，我們要先了解 pickle 這個 module 是做甚麼的。</p>
<p>Pickle module 主要是用來對物件進行 serialize 與 deserialize 的動作。簡單地說，serialize 就是把物件轉換成另一個儲存形式 (像是字串或其他二進位碼)，deserialize 則是把資料還原成物件。其中，<code>pickle.dumps()</code> 就是在 serialize，<code>pickle.loads()</code> 就是在 deserialize。</p>
<p>而啟動 shell 的動作就發生在 <code>b = pickle.loads(a)</code> 這行，也就是將資料還原成物件的時候。</p>
<p>這主要是因為，<code>Exploit</code> 這個 class 中的 method <code>__reduce__</code> 回傳了一組 tuple，<code>(os.system, (comm,))</code>。</p>
<p>Pickle module 的文件中有寫到，class 可以提供一個稱為 <code>__reduce__</code> 的 method 來說明如何 deserialize 物件。這個 <code>__reduce__</code> method 必須要傳回一些數值，來指示如何還原物件。第一個數值代表初始化物件的時候必須要呼叫的 function，第二個數值則是該 function 的參數。如果你仔細對照一下上面的程式碼，就會發現第一個回傳值為 <code>os.system</code>，第二個則為一個只有包含 <code>comm</code> 的 tuple。其結果是，會導致程式在 deserialize 時執行 <code>os.system(&quot;sh&quot;)</code> 這段程式碼，而啟動 shell。</p>
<p>這確實非常有趣XD</p>
<p>後來社團的前輩們就以這題為基礎，在一台 server 上架了一個 service。該 service 包含著這個漏洞，因此可以利用這個漏洞取得該機器上的資訊。</p>
<p>同時他們也鼓勵利用 Python script 來寫這題，讓我好好地把前面學的很多東西都用上了！</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>光是今天的課就感覺收穫不少，而且前輩們在練習期間，也非常友善地不斷關心社員是否遇到甚麼問題。也不會因為我是清大來的就把我晾在一邊XD。這些讓我非常期待接下來的課程。</p>
<p>希望之後上課也能夠像今天這樣寫下心得與筆記。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天去參加了交大 &lt;a href=&quot;https://bamboofox.torchpad.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BambooFox&lt;/a&gt; 的第一堂社課，收穫不少。因此我想寫下一些參與的心得，並記錄一些學習到的技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="CTF" scheme="http://www.slmt.tw/blog/categories/ctf/"/>
    
      <category term="BambooFox" scheme="http://www.slmt.tw/blog/categories/ctf/bamboofox/"/>
    
    
      <category term="bamboofox" scheme="http://www.slmt.tw/blog/tags/bamboofox/"/>
    
      <category term="ctf" scheme="http://www.slmt.tw/blog/tags/ctf/"/>
    
      <category term="club" scheme="http://www.slmt.tw/blog/tags/club/"/>
    
  </entry>
  
  <entry>
    <title>新 Blog 開張!!</title>
    <link href="http://www.slmt.tw/blog/2015/07/25/new-blog-annonced/"/>
    <id>http://www.slmt.tw/blog/2015/07/25/new-blog-annonced/</id>
    <published>2015-07-24T16:00:00.000Z</published>
    <updated>2016-07-04T06:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>這篇原先是為了我在 Jekyll 的部落格寫的，對於現在這個 blog 來說已經算是舊文囉！</p>
<a id="more"></a>
<p>這裏是我的新 blog</p>
<p>對於一般來訪的人來說，應該只會覺得外觀有改變而已。但是事實上，連後端也改變很多！之前的 blog 是先在我個人的 VM 上裝上 <a href="http://httpd.apache.org/" target="_blank" rel="external">Apache HTTP Server</a>，然後再將他人撰寫的 <a href="https://tw.wordpress.org/" target="_blank" rel="external">WordPress</a> 丟在 server 上執行。不過其實我很快就發現這個做法的大問題。我個人可以很簡單地，使用 DoS 攻擊 (Denial of Service Attack)，就能夠讓我的 server 當機。</p>
<p>因此從那時開始，我就一直在尋覓各種解決方法，或是替代方案。</p>
<p>另外，WordPress 提供了蠻多功能，但是我個人其實不太需要這麼多功能。對於一個不會寫網頁的人來說，WordPress 確實是架設網站的一個很好選擇。不過對一個只想架設一個簡單 blog 的軟體工程師來說，WordPress 實在是太肥了點。</p>
<p>同時租用一個 VM 也是要錢的 （每個月 10 鎂，約台幣 300），所以能有一個便宜，甚至不用錢的解決方案最好。</p>
<p>幸好，實驗室學長 <a href="http://shaokanp.me/" target="_blank" rel="external">Marcus</a> 告訴我了另一個選擇。他說我可以使用 <a href="http://jekyllrb.com/" target="_blank" rel="external">Jekyll</a> 在 <a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a> 上架設 blog。</p>
<p>最初我並沒有很認真地考慮，但是後來仔細一看之後，發現這是一個適合工程師，也很適合我的解決方案。</p>
<p>基本上使用 Jekyll 不需要任何後台管理。撰寫 blog 文章主要是透過撰寫一份 Markdown 文件來進行，然後 Jekyll 會根據你事先寫好的模板將文件轉換成靜態網頁。最後只要將網頁上傳到一個網路空間即可。</p>
<p>剛好 Github 有提供幫你 host 靜態網頁的功能，因此我就使用了 <a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a> 這個服務。唯一的缺點是，你的所有程式碼都會公開在 Github 上，只是我個人不覺得這是大問題就是了XD</p>
<p>本 blog 原始碼位置： <a href="https://github.com/SLMT/slmt.github.io" target="_blank" rel="external">https://github.com/SLMT/slmt.github.io</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這篇原先是為了我在 Jekyll 的部落格寫的，對於現在這個 blog 來說已經算是舊文囉！&lt;/p&gt;
    
    </summary>
    
      <category term="Building Blog" scheme="http://www.slmt.tw/blog/categories/building-blog/"/>
    
      <category term="Jekyll" scheme="http://www.slmt.tw/blog/categories/building-blog/jekyll/"/>
    
    
      <category term="blog" scheme="http://www.slmt.tw/blog/tags/blog/"/>
    
      <category term="github pages" scheme="http://www.slmt.tw/blog/tags/github-pages/"/>
    
  </entry>
  
  <entry>
    <title>版本編號的命名規則</title>
    <link href="http://www.slmt.tw/blog/2015/07/20/version-number-naming-convention/"/>
    <id>http://www.slmt.tw/blog/2015/07/20/version-number-naming-convention/</id>
    <published>2015-07-19T16:00:00.000Z</published>
    <updated>2016-07-04T06:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在研究如何命名軟體的版本編號，比較符合現在常用的命名方式。當然版本號可以隨意訂，但是使用了一個大家通用的規則的話，其他人也比較容易從版本號上看出了不同版本之間的變化有多大。以下分享我所瞭解到的命名規則。</p>
<a id="more"></a>
<h2 id="命名規則"><a href="#命名規則" class="headerlink" title="命名規則"></a>命名規則</h2><p>首先，在開始分享之前，先提供一份參考文件。基本上我就是遵照這份文件的所定義的規則。</p>
<p>Semantic Versioning: <a href="http://semver.org/" target="_blank" rel="external">http://semver.org/</a></p>
<p>這份文件有提供多種不同的語言供大家閱讀，我看了一下中文的翻譯也沒什麼問題，應該可以安心食用XD</p>
<p>那麼接下來就大致介紹一下主要的規則。</p>
<h3 id="版本編號格式"><a href="#版本編號格式" class="headerlink" title="版本編號格式"></a>版本編號格式</h3><p>版本編號必須要依照以下格式命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[主版本號].[次版本號].[修訂版本號]</div></pre></td></tr></table></figure>
<p>以上每個編號都是 &gt;= 0 的數字，下面就是一個符合規則的版本編號：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.0.3</div></pre></td></tr></table></figure>
<p>每次一發佈新版本的時候就遞增其中一個編號。</p>
<h3 id="每個編號遞增的時機"><a href="#每個編號遞增的時機" class="headerlink" title="每個編號遞增的時機"></a>每個編號遞增的時機</h3><ul>
<li>主版本號：軟體有重大更新的時候遞增，重大更新通常是指功能與介面都有大幅度變動的時候。</li>
<li>次版本號：軟體發佈新功能，但是並不會大幅影響到整個軟體的時候遞增。</li>
<li>修訂版本號：通常是在軟體有 bug，發布 bug 的修正版時遞增。</li>
</ul>
<p>有些版本編號除了上述三者之外，還會有「建置版本號」。也就是只要每次建置一次軟體就會遞增一次，有時候甚至會使用建置的日期或時間來代表。不過已經很少人在用了。</p>
<h3 id="版本號的比較"><a href="#版本號的比較" class="headerlink" title="版本號的比較"></a>版本號的比較</h3><p>比較的規則很簡單，就是從最左邊的數字開始比。比較大的就是比較新的版本。</p>
<p>如果數字一樣的話，就比下一個數字。</p>
<p>以下是一個比較的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.0.0 &lt; 1.0.1 &lt; 1.1.0 &lt; 1.2.0 &lt; 1.4.5 &lt; 2.0.0 &lt; 2.1.12 &lt; 2.3.2 &lt; 3.0.0 ...</div></pre></td></tr></table></figure>
<h3 id="正式版之前的測試版本編號"><a href="#正式版之前的測試版本編號" class="headerlink" title="正式版之前的測試版本編號"></a>正式版之前的測試版本編號</h3><p>有些軟體在發布正式版本之前，會先發布測試版本給大眾使用。測試版本不保證沒有任何 bug 或者功能完善。</p>
<p>通常測試版的 <code>主版本號</code> 會是 <code>0</code>，例如 <code>0.3.1</code> 就是一個測試版本。</p>
<p>而一般會使用 <code>0.1.0</code> 當作測試版的初始版本號。</p>
<h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3><p>除了以上規則之外，還有些規則的細節沒有提及。如果有興趣的話可以直接看看最上面提供的文件。</p>
<h2 id="命名範例"><a href="#命名範例" class="headerlink" title="命名範例"></a>命名範例</h2><p>以下分別以「線上遊戲」與「函式庫」兩者為例。</p>
<h3 id="線上遊戲"><a href="#線上遊戲" class="headerlink" title="線上遊戲"></a>線上遊戲</h3><p>假設現在有款 RPG 線上遊戲叫做 <code>小山貓 online</code>，一開始正式發佈的版本號是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.0.0</div></pre></td></tr></table></figure>
<p>接著推出一段時間之後，為了增加遊戲的豐富性，新增了一些新的關卡與任務，此時 <code>次版本號</code> 有可能就會遞增：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.1.0</div></pre></td></tr></table></figure>
<p>新增了新功能不久，有玩家回報在解任務時會卡住，沒辦法繼續。工程師檢查之下發現是 bug，立即修正。因此發佈了 bug 修正版，<code>修正版本號</code> 遞增：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.1.1</div></pre></td></tr></table></figure>
<p>過了一段時間，又發布了新的關卡與任務，因此 <code>次版本號</code> 再度遞增，而 <code>修正版本號</code> 歸零：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.2.0</div></pre></td></tr></table></figure>
<p>就這樣持續了一段時間。隨著時間的推進，現有的地圖與故事似乎無法滿足玩家的需求，因此遊戲公司撰寫了新故事與製作了新地圖，推出了 <code>小山貓的遠征之旅</code> 大改版！</p>
<p>這個時候，遊戲出現了重大更新，所以 <code>主版本號</code> 很有可能就會遞增，後面的版本號則歸零：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.0.0</div></pre></td></tr></table></figure>
<p>這是一個線上遊戲可能的版本編號命名時機與流程。</p>
<h3 id="函式庫"><a href="#函式庫" class="headerlink" title="函式庫"></a>函式庫</h3><p>函式庫的狀況與遊戲不同，因為使用函式庫的人通常是開發其他程式的工程師，所以版本號遞增的時機也會不太一樣。</p>
<p>假設我寫了一個 <code>小山貓函式庫</code>，只要呼叫一個 <code>catMeow()</code> 這個函式，電腦喇叭就會發出貓咪的叫聲。</p>
<p>而版本編號一開始可能訂為：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.0.0</div></pre></td></tr></table></figure>
<p>此時我心血來潮，突然想要新增一個新的函式（新功能），<code>catAnimate()</code> 函式，呼叫之後程式畫面中就會出現貓咪動畫。</p>
<p><code>次版本號</code> 可能就會遞增：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.1.0</div></pre></td></tr></table></figure>
<p>我突然接到其他開發者來信，他說他們呼叫了新的 <code>catAnimate()</code> 之後，沒有出現貓，而是出現狗！</p>
<p>這真是太嚴重了！必須要馬上修正這個 bug！因此我發布了一個修訂版本，且遞增了 <code>修訂版本號</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1.1.1</div></pre></td></tr></table></figure>
<p>過了一段時間之後，我覺得現在這個 API 設計不好，我想用物件導向的方式重寫。</p>
<p>在重寫之後，任何人使用舊的功能之前，必須要先使用 <code>new Cat()</code> 建立一個貓咪物件，然後分別呼叫 <code>cat.meow()</code> 與 <code>cat.animate()</code> 才能使用之前的功能。</p>
<p>這個改變影響到了許多已經寫好程式的開發者，因為他們必須要把所有使用到 <code>小山貓函式庫</code> 的地方全部改成新的寫法。</p>
<p>為了因應這種重大更新，此時必須要遞增 <code>主版本號</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.0.0</div></pre></td></tr></table></figure>
<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>大家應該可以注意到一件事情，通常遊戲的重大更新對玩家來說都是一個令人開心的事件，但是函式庫的重大更新（主版本號遞增）通常對開發者來說就代表著：「Fxxk！程式又要大修了！」</p>
<p>開發者會視情況來決定是否要使用大更新後的函式庫。有很多情況是，開發者仍使用舊的版本（像是 <code>小山貓函式庫</code> 的 <code>1.1.1</code> 版），而只有開發新程式的時候才會使用最新的版本。</p>
<p>例如 OpenGL 某次重大更新之後，大大地修改了繪圖的流程與方式，很多舊的函式都不能呼叫了，因此到現在還是很多人使用舊版。另外像是 Python 3 的更新也改掉了很多語法的使用方式。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這邊提供的只是一種目前常看到的命名規則。當然要自己定義自己的規則也不是不行，像是直接用發布日期來當版本號，只是其他人就無法使用這種常用的邏輯來判斷版本號的意義。此時最好提供一份文件說明這些版本號的意義。</p>
<p>另外，有些軟體在測試期間，可能會使用不同規則的命名方式。</p>
<p>例如從 <a href="https://mcversions.net/" target="_blank" rel="external">這份下載清單</a> 可以看到， <a href="https://minecraft.net/" target="_blank" rel="external">Minecraft</a> 在測試期間的版本編號，是在前面分別加上 <code>a</code> 代表 alpha 版，加上 <code>b</code> 代表 beta 版。正式版本再使用類似這裡分享的規則來命名。</p>
<p>我個人是建議就遵照最上方文件提供的規則就好，使用一個大多數人都使用的規則並沒有什麼壞處。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近正在研究如何命名軟體的版本編號，比較符合現在常用的命名方式。當然版本號可以隨意訂，但是使用了一個大家通用的規則的話，其他人也比較容易從版本號上看出了不同版本之間的變化有多大。以下分享我所瞭解到的命名規則。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://www.slmt.tw/blog/categories/programming/"/>
    
      <category term="Software Engineering" scheme="http://www.slmt.tw/blog/categories/programming/software-engineering/"/>
    
    
      <category term="dev" scheme="http://www.slmt.tw/blog/tags/dev/"/>
    
      <category term="version control" scheme="http://www.slmt.tw/blog/tags/version-control/"/>
    
      <category term="naming convention" scheme="http://www.slmt.tw/blog/tags/naming-convention/"/>
    
  </entry>
  
  <entry>
    <title>在 WordPress 的文章中使用 Syntax Highlighting</title>
    <link href="http://www.slmt.tw/blog/2015/07/19/syntax-highlighting-for-wordpress/"/>
    <id>http://www.slmt.tw/blog/2015/07/19/syntax-highlighting-for-wordpress/</id>
    <published>2015-07-18T16:00:00.000Z</published>
    <updated>2016-07-04T06:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章原本是為了要處理舊部落格之中遇到的問題所寫的，不過現在這個問題在新部落格已經不存在了。因此我就簡短說明一下狀況與解決辦法。</p>
<a id="more"></a>
<p>舊部落格使用的是 WordPress 系統，當我們發表一篇文章的時候，如果想要在其中嵌入一段程式碼，就會在文章前後加入 <code>&lt;code&gt;...&lt;/code&gt;</code> tags。</p>
<p>不過我後來發現 WordPress 沒有提供 syntax highlighting 的功能，也就是把你的程式碼依照對應的語言以及語法加上容易辨識的顏色。</p>
<p>像是假設我現在想要給大家看一段 java code，那我可能就會這樣打：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></div><div class="line">package slmt.test;</div><div class="line"></div><div class="line">public class Cat &#123;</div><div class="line">    public static void meow() &#123;</div><div class="line">        System.out.println("I'm a cat~ Meow!!");</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然後顯示出來的效果就會像這樣：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> slmt.test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">meow</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm a cat~ Meow!!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是 WordPress 並沒有提供這樣的功能。</p>
<p>幸好在同實驗室的學長 <a href="http://shaokanp.me/" target="_blank" rel="external">Pi 先生</a>的建議下，得知了 <a href="http://prismjs.com/" target="_blank" rel="external">稜鏡.js</a> 這套 library。並且在使用之後，確認 WordPress 也能夠很輕易地套用。</p>
<p>雖然我現在使用的 jekyll 內已經有內建這項功能了，不過還是將這個 library 分享給大家，讓使用 WordPress 的朋友能夠輕鬆幫自己的 code 上色XD</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這篇文章原本是為了要處理舊部落格之中遇到的問題所寫的，不過現在這個問題在新部落格已經不存在了。因此我就簡短說明一下狀況與解決辦法。&lt;/p&gt;
    
    </summary>
    
      <category term="Building Blog" scheme="http://www.slmt.tw/blog/categories/building-blog/"/>
    
      <category term="Word Press" scheme="http://www.slmt.tw/blog/categories/building-blog/word-press/"/>
    
    
      <category term="syntax" scheme="http://www.slmt.tw/blog/tags/syntax/"/>
    
      <category term="highlight" scheme="http://www.slmt.tw/blog/tags/highlight/"/>
    
      <category term="blog" scheme="http://www.slmt.tw/blog/tags/blog/"/>
    
      <category term="wordpress" scheme="http://www.slmt.tw/blog/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>Dcard 文章研究 (1) - 從 Dcard API 取得文章</title>
    <link href="http://www.slmt.tw/blog/2015/02/19/dcard-research-1/"/>
    <id>http://www.slmt.tw/blog/2015/02/19/dcard-research-1/</id>
    <published>2015-02-18T16:00:00.000Z</published>
    <updated>2016-07-04T06:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>因為我過年的時候蠻無聊的，雖然有研究上的正事要做，但是我還是想做一點自己的事情。正好最近 Dcard，這個專門為大學生開設的交友網站非常熱門，裡面有著各式各樣的文章，所以我就一時興起把上面的文章抓下來看看能做什麼樣的研究。</p>
<a id="more"></a>
<h1 id="Dcard-簡介"><a href="#Dcard-簡介" class="headerlink" title="Dcard 簡介"></a>Dcard 簡介</h1><p>傳送門：<a href="http://www.dcard.tw/" target="_blank" rel="external">http://www.dcard.tw/</a></p>
<p>Dcard 成立於 2011 年，是一個以大學生為客群的交友網站。其最大的特色在於其每天午夜的抽卡機制。</p>
<h3 id="抽卡機制"><a href="#抽卡機制" class="headerlink" title="抽卡機制"></a>抽卡機制</h3><p>其抽卡機制的運作方式為，每當到午夜時，每一位註冊的會員會收到一張卡片。卡片上包含著另一位會員的自我介紹，以及該會員的照片。如果想要認識對方，就必須要送出邀請信。但是唯有當兩方都有送出邀請時，才會看到對方的邀請信的內容，並成為朋友。如果有其中一方直至下次午夜前尚未送出邀請，那張卡片就會消失，以後不會再抽到同一個人。</p>
<h3 id="匿名討論區"><a href="#匿名討論區" class="headerlink" title="匿名討論區"></a>匿名討論區</h3><p>除了抽卡之外，Dcard 也提供了一個匿名討論區。討論區上有十幾種討論版，依據不同的討論議題分類，像是：時事、男女關係、音樂、電影…等等。在上面無論發文或回文，只會顯示學校與系名，甚至某些狀況下能夠完全隱藏上述資訊，只留下性別供人判斷。若在文中流露太多辨別身份的資訊，則會被直接刪除。因此他人幾乎無法辨別每一則文章或留言是由誰所撰寫。</p>
<p>因為 Dcard 的註冊流程繁雜，加上註冊者必須要具備經過 Dcard 認證的學校電子信箱。因此幾乎可以確定註冊者就是大學生。並且在特殊抽卡機制的驅使下，使得使用者更喜歡在 Dcard 上活動。這也造就了 Dcard 匿名討論區熱絡討論的狀況。</p>
<h1 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h1><p>這次主要是要研究其匿名討論區的部分。因為討論區是公開給任何人觀賞，所以資料取得就沒有隱私的問題。雖然我有想過要取得抽卡的資料，不過這並非是短時間內就可以收集起來的，因而作罷。看看有沒有辦法從文章中挖出什麼有趣的訊息。</p>
<h1 id="爬文章"><a href="#爬文章" class="headerlink" title="爬文章"></a>爬文章</h1><p>既然是要研究文章，那我勢必是要把 Dcard 上所有文都先抓下來。</p>
<p>身為一個 Programmer，我們當然不會一篇一篇地用瀏覽器打開文章，然後一篇一篇地存起來。因此這邊我們就要寫一個爬蟲來自動幫我們把所有文章都抓下來，以方便我們做研究。</p>
<h3 id="網路監測"><a href="#網路監測" class="headerlink" title="網路監測"></a>網路監測</h3><p>那要怎麼樣讓程式能夠自動找出文章，然後存下來呢？</p>
<p>我們可以先瞭解一下，到底 Dcard 是怎麼從伺服器上取得文章的？</p>
<p>幸虧現在的瀏覽器都有很強大的 debug 功能，我們可以很簡單地知道當我們進入 Dcard 網站時，瀏覽器到底跟伺服器送了哪些請求，得到了哪些回覆。</p>
<p>當在使用 Firefox 或者 Google Chrome 時，你可以按下 F12 (Mac 是按 fn + F12) 呼叫出 debug 視窗。此時只要選擇其中一個頁籤「網路」，就可以監測有哪些請求與回覆。</p>
<p>當你打開畫面後，此時點選一個 Dcard 上的文章，就會顯示像是下圖的資訊：<br><a href="/images/20150219001.png"><img src="/images/20150219001.png"></a></p>
<p>因為在下曾經有參與過寫網站與 App 的經驗，此時我就發現其中有幾個請求很可疑。我們先看「類型」那一行，該行所代表的就是伺服器回應時所傳遞的資料格式。其中第一個與第三個請求都是收到 JSON 的回覆，這代表我們很有可能中大獎了！</p>
<p>JSON 是一種常用於傳遞小型資料的格式，現在廣泛使用於 App 與伺服器之間的溝通。因為 Dcard 除了網站之外，還有開發 App 版本，因此使用 JSON 搭配 RESTful API 來傳遞資料也是很合理的做法。</p>
<h3 id="分析-API"><a href="#分析-API" class="headerlink" title="分析 API"></a>分析 API</h3><p>當我們點選上圖中的第一個請求之後，馬上就會跳出另一個視窗。此時我們點選「回應」，就可以看見伺服器回覆的內容：</p>
<p><a href="/images/20150219002.png"><img src="/images/20150219002.png"></a></p>
<p>大致看下來之後，就知道這鐵定是文章的資料沒錯！內容大約是文章的一些資料，像是 fourm_alias 就是代表這個文章屬於哪個版，updatedAt 就是最近一次更新時間，likeCount 就是點讚數等等。</p>
<p>若進一步點開 version 這個 object，就可以發現裡面放的就是文章的內文。comment 點開則可以看到文章下面的留言與留言者的學校與系名。</p>
<p>看到這邊，就知道這一個 JSON object 裡面所包含的資料就是這整份文章的資料了！因此我們只要能夠找到所有文章的 JSON object，就可以把所有文章都存在自己電腦裡。</p>
<p>這時我們再點選「檔頭」，可以看到這些資料：</p>
<p><a href="/images/20150219003.png"><img src="/images/20150219003.png"></a></p>
<p>最重要的是上面「URL」的部分。我們可以看到這個網址是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.dcard.tw/api/post/all/85846</div></pre></td></tr></table></figure>
<p><code>www.dcard.tw</code> 當然是伺服器的網址，而剩下 <code>api/post/all/85846</code> 就是可以取得這篇文章 JSON object 的位址。</p>
<p>這邊大致可以猜到文章的 API 八成是這樣：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.dcard.tw/api/post/all/[post-id]</div></pre></td></tr></table></figure>
<p>如果我們將 85846 換成別的數字，像是 84840：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.dcard.tw/api/post/all/85840</div></pre></td></tr></table></figure>
<p>然後把這個網址輸入瀏覽器的網址列，按下 enter，就會出現：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"forum_alias"</span>: <span class="string">"bg"</span>,</div><div class="line">  <span class="string">"pinned"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"anonymousDepartment"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"anonymousSchool"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"reply"</span>: <span class="number">-1</span>,</div><div class="line">  <span class="string">"updatedAt"</span>: <span class="string">"2015-02-18T18:38:15.890Z"</span>,</div><div class="line">  <span class="string">"createdAt"</span>: <span class="string">"2015-02-18T18:04:07.135Z"</span>,</div><div class="line">  <span class="string">"follow"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="string">"comment"</span>: [...],</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大致看下來應該可以發現這是另一個文章的 JSON object。</p>
<p>那麼毫無疑問，那個數字就是文章的 id(編號)，而那段網址就是能夠取得文章 JSON object 的 API。並且幸運的是，文章編號看起來是從依序給定的。也就是說，假設最新的文章編號是 85846，那我們只需要從 0 掃到 85846，應該就可以取得 Dcard 上所有文章的 JSON object。</p>
<p>下次再來說該怎麼抓下來，怎麼處理吧～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因為我過年的時候蠻無聊的，雖然有研究上的正事要做，但是我還是想做一點自己的事情。正好最近 Dcard，這個專門為大學生開設的交友網站非常熱門，裡面有著各式各樣的文章，所以我就一時興起把上面的文章抓下來看看能做什麼樣的研究。&lt;/p&gt;
    
    </summary>
    
      <category term="Research" scheme="http://www.slmt.tw/blog/categories/research/"/>
    
      <category term="Dcard" scheme="http://www.slmt.tw/blog/categories/research/dcard/"/>
    
    
      <category term="research" scheme="http://www.slmt.tw/blog/tags/research/"/>
    
      <category term="dcard" scheme="http://www.slmt.tw/blog/tags/dcard/"/>
    
  </entry>
  
</feed>
